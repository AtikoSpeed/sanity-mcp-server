#!/usr/bin/env node
/**
 * Complexity Analysis Script
 * 
 * This script analyzes the complexity report generated by ESLint
 * and generates a metrics file with summarized complexity data.
 * It also identifies high-complexity functions for improvement.
 * 
 * HARD FAIL IMPLEMENTATION: This script will fail with an error if:
 * - The complexity report doesn't exist or is invalid
 * - No complexity metrics can be extracted
 * - High-complexity functions are found above critical thresholds
 */

import fs from 'fs';
import path from 'path';

// File paths
const COMPLEXITY_REPORT = './scripts/quality/output/complexity-report.json';
const COMPLEXITY_METRICS = './scripts/quality/output/complexity-metrics.json';
const COMPLEXITY_RESULTS = './scripts/quality/output/complexity-results.txt';
const IMPROVEMENT_OPPORTUNITIES = './scripts/quality/output/improvement-opportunities.json';

// Thresholds for categorizing complexity
const COMPLEXITY_THRESHOLDS = {
  low: 5,
  medium: 10,
  high: 15,
  critical: 20
};

/**
 * Main function to analyze complexity
 */
function analyzeComplexity() {
  console.log('Analyzing code complexity...');
  
  // Check if complexity report exists
  if (!fs.existsSync(COMPLEXITY_REPORT)) {
    throw new Error(`Complexity report not found at ${COMPLEXITY_REPORT}. Run ESLint complexity checks first.`);
  }
  
  // Read the complexity report
  let eslintReport;
  try {
    eslintReport = JSON.parse(fs.readFileSync(COMPLEXITY_REPORT, 'utf8'));
  } catch (error) {
    throw new Error(`Error reading complexity report: ${error.message}. Ensure valid JSON output from ESLint.`);
  }
  
  // Process the report
  const complexityData = processComplexityReport(eslintReport);
  
  // Validate complexity data
  validateComplexityData(complexityData);
  
  // Generate metrics
  const metrics = generateMetrics(complexityData);
  
  // Save metrics to file
  fs.writeFileSync(COMPLEXITY_METRICS, JSON.stringify(metrics, null, 2));
  console.log(`Complexity metrics saved to ${COMPLEXITY_METRICS}`);
  
  // Save text report
  const textReport = generateTextReport(complexityData, metrics);
  fs.writeFileSync(COMPLEXITY_RESULTS, textReport);
  console.log(`Complexity results saved to ${COMPLEXITY_RESULTS}`);
  
  // Save improvement opportunities
  const opportunities = generateImprovementOpportunities(complexityData);
  fs.writeFileSync(IMPROVEMENT_OPPORTUNITIES, JSON.stringify(opportunities, null, 2));
  console.log(`Improvement opportunities saved to ${IMPROVEMENT_OPPORTUNITIES}`);
  
  // Return data for testing/validation
  return {
    complexityData,
    metrics,
    opportunities
  };
}

/**
 * Validates complexity data to ensure it's complete and valid
 * @param {Object} complexityData - The complexity data to validate
 * @throws {Error} If validation fails
 */
function validateComplexityData(complexityData) {
  if (!complexityData) {
    throw new Error('No complexity data generated. Check ESLint configuration.');
  }
  
  if (!complexityData.functions || complexityData.functions.length === 0) {
    throw new Error('No functions with complexity metrics found. Check code files and ESLint rules.');
  }
  
  if (complexityData.totalFiles === 0) {
    throw new Error('No files with complexity metrics found. Check code files and ESLint rules.');
  }
  
  // Ensure we have valid timestamps within the last hour
  const currentTimestamp = new Date().getTime();
  const oneHourInMs = 60 * 60 * 1000;
  
  if (complexityData.timestamp && (currentTimestamp - new Date(complexityData.timestamp).getTime() > oneHourInMs)) {
    throw new Error('Complexity data is too old. Regenerate with current code.');
  }
  
  console.log('Complexity data validation passed.');
  return true;
}

/**
 * Process the ESLint complexity report
 */
function processComplexityReport(eslintReport) {
  // Initialize data structure
  const complexityData = {
    files: {},
    functions: [],
    totalFiles: 0,
    totalFunctions: 0,
    totalComplexity: 0
  };
  
  // Process each file in the report
  for (const result of eslintReport) {
    const filePath = result.filePath;
    const fileName = path.basename(filePath);
    
    let fileComplexity = 0;
    let fileFunctions = 0;
    
    // Process each message (issue) in the file
    for (const message of result.messages) {
      // Look for complexity-related messages
      if (message.ruleId === 'complexity' || message.ruleId === 'sonarjs/cognitive-complexity') {
        fileFunctions++;
        
        // Extract complexity value from message
        const complexityMatch = message.message.match(/complexity of (\d+)/);
        if (!complexityMatch) continue;
        
        const complexity = parseInt(complexityMatch[1], 10);
        fileComplexity += complexity;
        
        // Extract function name if available
        let functionName = 'unknown';
        const nameMatch = message.message.match(/function ['"]?([^'"()]+)['"]? has/);
        if (nameMatch) {
          functionName = nameMatch[1];
        }
        
        // Add to functions list - explicitly casting to any first to avoid type errors
        const functionInfo = {
          file: filePath,
          name: functionName,
          complexity,
          severity: getSeverity(complexity),
          line: message.line
        };
        
        complexityData.functions.push(functionInfo);
        
        // Update totals
        complexityData.totalFunctions++;
        complexityData.totalComplexity += complexity;
      }
    }
    
    // Only count files that have functions with complexity issues
    if (fileFunctions > 0) {
      complexityData.files[filePath] = {
        name: fileName,
        complexity: fileComplexity,
        functions: fileFunctions,
        averageComplexity: fileFunctions > 0 ? fileComplexity / fileFunctions : 0
      };
      
      complexityData.totalFiles++;
    }
  }
  
  return complexityData;
}

/**
 * Generate complexity metrics
 */
function generateMetrics(complexityData) {
  // Calculate overall metrics
  const averageComplexity = complexityData.totalFunctions > 0
    ? complexityData.totalComplexity / complexityData.totalFunctions
    : 0;
  
  // Count functions by severity
  const severityCounts = {
    low: 0,
    medium: 0,
    high: 0,
    critical: 0
  };
  
  for (const func of complexityData.functions) {
    severityCounts[func.severity]++;
  }
  
  // Generate metrics object
  const metrics = {
    timestamp: new Date().toISOString(),
    metrics: {
      totalFiles: complexityData.totalFiles,
      totalFunctions: complexityData.totalFunctions,
      totalComplexity: complexityData.totalComplexity,
      averageComplexity: Number(averageComplexity.toFixed(2)),
      highComplexityFunctions: severityCounts.high + severityCounts.critical,
      criticalComplexityFunctions: severityCounts.critical,
      lowComplexityFunctions: severityCounts.low,
      mediumComplexityFunctions: severityCounts.medium,
      complexityDistribution: {
        low: severityCounts.low,
        medium: severityCounts.medium,
        high: severityCounts.high,
        critical: severityCounts.critical
      }
    },
    thresholds: COMPLEXITY_THRESHOLDS,
    topFiles: getTopComplexFiles(complexityData, 10),
    topFunctions: getTopComplexFunctions(complexityData, 10)
  };
  
  return metrics;
}

/**
 * Generate improvement opportunities
 */
function generateImprovementOpportunities(complexityData) {
  const opportunities = [];
  
  // Add high complexity functions
  for (const func of complexityData.functions) {
    if (func.severity === 'high' || func.severity === 'critical') {
      opportunities.push({
        file: func.file,
        description: `Function "${func.name}" has a complexity of ${func.complexity}`,
        impact: func.severity === 'critical' ? 'high' : 'medium',
        type: 'complexity'
      });
    }
  }
  
  // Sort by impact and complexity
  opportunities.sort((a, b) => {
    if (a.impact === b.impact) {
      // Safe regex match with null check
      const complexityAMatch = a.description.match(/complexity of (\d+)/);
      const complexityBMatch = b.description.match(/complexity of (\d+)/);
      
      const complexityA = complexityAMatch ? parseInt(complexityAMatch[1], 10) : 0;
      const complexityB = complexityBMatch ? parseInt(complexityBMatch[1], 10) : 0;
      
      return complexityB - complexityA;
    }
    return a.impact === 'high' ? -1 : 1;
  });
  
  return opportunities;
}

/**
 * Generate text report
 */
function generateTextReport(complexityData, metrics) {
  let report = '# Complexity Analysis Report\n\n';
  
  // Add summary
  report += '## Summary\n\n';
  report += `Total Files: ${metrics.metrics.totalFiles}\n`;
  report += `Total Functions: ${metrics.metrics.totalFunctions}\n`;
  report += `Average Complexity: ${metrics.metrics.averageComplexity.toFixed(2)}\n`;
  report += `High Complexity Functions: ${metrics.metrics.highComplexityFunctions}\n`;
  report += `Critical Complexity Functions: ${metrics.metrics.criticalComplexityFunctions}\n\n`;
  
  // Add complexity distribution
  report += '## Complexity Distribution\n\n';
  report += `Low (1-${COMPLEXITY_THRESHOLDS.low}): ${metrics.metrics.complexityDistribution.low}\n`;
  report += `Medium (${COMPLEXITY_THRESHOLDS.low+1}-${COMPLEXITY_THRESHOLDS.medium}): ${metrics.metrics.complexityDistribution.medium}\n`;
  report += `High (${COMPLEXITY_THRESHOLDS.medium+1}-${COMPLEXITY_THRESHOLDS.high}): ${metrics.metrics.complexityDistribution.high}\n`;
  report += `Critical (>${COMPLEXITY_THRESHOLDS.high}): ${metrics.metrics.complexityDistribution.critical}\n\n`;
  
  // Add top complex files
  report += '## Top Complex Files\n\n';
  for (const file of metrics.topFiles) {
    report += `${file.name} - ${file.complexity} (${file.functions} functions, avg: ${file.averageComplexity.toFixed(2)})\n`;
  }
  report += '\n';
  
  // Add top complex functions
  report += '## Top Complex Functions\n\n';
  for (const func of metrics.topFunctions) {
    report += `${func.name} in ${path.basename(func.file)} - ${func.complexity} (${func.severity})\n`;
  }
  
  return report;
}

/**
 * Get top complex files
 */
function getTopComplexFiles(complexityData, count) {
  const files = Object.values(complexityData.files);
  
  // Sort by total complexity
  files.sort((a, b) => b.complexity - a.complexity);
  
  return files.slice(0, count);
}

/**
 * Get top complex functions
 */
function getTopComplexFunctions(complexityData, count) {
  // Sort by complexity
  const functions = [...complexityData.functions];
  functions.sort((a, b) => b.complexity - a.complexity);
  
  return functions.slice(0, count);
}

/**
 * Get severity level based on complexity
 */
function getSeverity(complexity) {
  if (complexity <= COMPLEXITY_THRESHOLDS.low) {
    return 'low';
  } else if (complexity <= COMPLEXITY_THRESHOLDS.medium) {
    return 'medium';
  } else if (complexity <= COMPLEXITY_THRESHOLDS.high) {
    return 'high';
  } else {
    return 'critical';
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  try {
    analyzeComplexity();
  } catch (error) {
    console.error('ERROR: Complexity analysis failed:');
    console.error(error.message);
    process.exit(1); // Hard fail with non-zero exit code
  }
}

// Export for use in other scripts
export { analyzeComplexity, validateComplexityData }; 
[{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/config/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/controllers/actions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createErrorResponse' is defined but never used.","line":7,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used.","line":11,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[367,370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[367,370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[439,442],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[439,442],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1016,1019],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1016,1019],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2492,2495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2492,2495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3123,3126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3123,3126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4500,4503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4500,4503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":2,"message":"Async function 'createDocument' has a complexity of 12. Maximum allowed is 10.","line":169,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":263,"endColumn":2},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 17 to the 10 allowed.","line":169,"column":23,"nodeType":null,"messageId":"refactorFunction","endLine":169,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5032,5035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5032,5035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5054,5057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5054,5057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5224,5227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5224,5227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":196,"column":27,"nodeType":"Literal","endLine":196,"endColumn":61},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6247,6250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6247,6250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6636,6639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6636,6639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":247,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":247,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7354,7357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7354,7357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7686,7689],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7686,7689],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":278,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8265,8268],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8265,8268],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":284,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":284,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8381,8384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8381,8384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":311,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9146,9149],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9146,9149],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":2,"message":"Async function 'deleteDocument' has a complexity of 11. Maximum allowed is 10.","line":326,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":426,"endColumn":2},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 14 to the 10 allowed.","line":326,"column":23,"nodeType":null,"messageId":"refactorFunction","endLine":326,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9865,9868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9865,9868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":347,"column":25,"nodeType":"Literal","endLine":347,"endColumn":63},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":422,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":422,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12337,12340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12337,12340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":439,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12834,12837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12834,12837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":439,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12856,12859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12856,12859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12974,12977],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12974,12977],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":479,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":479,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14032,14035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14032,14035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":510,"column":105,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":510,"endColumn":108,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14916,14919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14916,14919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":518,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":518,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15104,15107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15104,15107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":533,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":533,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15528,15531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15528,15531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":535,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":535,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15581,15584],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15581,15584],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":536,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":536,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15597,15600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15597,15600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":558,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":558,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16166,16169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16166,16169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":560,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":560,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16222,16225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16222,16225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":561,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":561,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16238,16241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16238,16241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":597,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":597,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17224,17227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17224,17227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":600,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":600,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17299,17302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17299,17302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":601,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":601,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17315,17318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17315,17318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":635,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":635,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18353,18356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18353,18356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":641,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":641,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18467,18470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18467,18470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":679,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":679,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19576,19579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19576,19579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":706,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":706,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20289,20292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20289,20292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":749,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":749,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21458,21461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21458,21461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":774,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":774,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22205,22208],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22205,22208],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":836,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":836,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24044,24047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24044,24047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":44,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSanityClient, sanityApi } from '../utils/sanityClient.js';\nimport { \n  normalizeDraftId, \n  normalizeBaseDocId, \n  applyPatchOperations, \n  getDocumentContent,\n  createErrorResponse\n} from '../utils/documentHelpers.js';\n\n// Define types for Sanity documents\ninterface SanityDocumentStub<T extends { _type: string }> {\n  _type: string;\n  [key: string]: any;\n}\n\ninterface IdentifiedSanityDocumentStub<T extends Record<string, any>> extends SanityDocumentStub<T & { _type: string }> {\n  _id: string;\n}\n\n/**\n * Publishes a document or multiple documents (makes draft the published version)\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param documentId - The document ID or array of IDs to publish\n * @returns Result of the publish operation\n */\nexport async function publishDocument(\n  projectId: string, \n  dataset: string, \n  documentId: string | string[]\n): Promise<{\n  success: boolean;\n  message: string;\n  documentId?: string;\n  documentIds?: string[];\n  result: any;\n}> {\n  try {\n    // Handle array of document IDs\n    if (Array.isArray(documentId)) {\n      const actions = documentId.map(id => {\n        // Ensure document ID doesn't already have 'drafts.' prefix\n        const baseDocId = id.replace(/^drafts\\./, '');\n        const draftId = `drafts.${baseDocId}`;\n        \n        return {\n          actionType: 'sanity.action.document.publish',\n          draftId,\n          publishedId: baseDocId\n        };\n      });\n      \n      // Call the Actions API with all actions at once\n      const result = await sanityApi.performActions(projectId, dataset, actions);\n      \n      return {\n        success: true,\n        message: `Published ${documentId.length} documents successfully`,\n        documentIds: documentId.map(id => id.replace(/^drafts\\./, '')),\n        result\n      };\n    } \n    \n    // Handle single document ID\n    // Ensure document ID doesn't already have 'drafts.' prefix\n    const baseDocId = documentId.replace(/^drafts\\./, '');\n    const draftId = `drafts.${baseDocId}`;\n    \n    // Create the publish action\n    const action = {\n      actionType: 'sanity.action.document.publish',\n      draftId,\n      publishedId: baseDocId\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Document ${baseDocId} published successfully`,\n      documentId: baseDocId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error publishing document:`, error);\n    throw new Error(`Failed to publish document: ${error.message}`);\n  }\n}\n\n/**\n * Unpublishes a document or multiple documents (keeps it as draft only)\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param documentId - The document ID or array of IDs to unpublish\n * @returns Result of the unpublish operation\n */\nexport async function unpublishDocument(\n  projectId: string, \n  dataset: string, \n  documentId: string | string[]\n): Promise<{\n  success: boolean;\n  message: string;\n  draftId?: string;\n  draftIds?: string[];\n  result: any;\n}> {\n  try {\n    // Handle array of document IDs\n    if (Array.isArray(documentId)) {\n      const actions = documentId.map(id => {\n        // Ensure document ID doesn't already have 'drafts.' prefix\n        const baseDocId = id.replace(/^drafts\\./, '');\n        \n        return {\n          actionType: 'sanity.action.document.unpublish',\n          documentId: baseDocId\n        };\n      });\n      \n      // Call the Actions API with all actions at once\n      const result = await sanityApi.performActions(projectId, dataset, actions);\n      \n      return {\n        success: true,\n        message: `Unpublished ${documentId.length} documents successfully`,\n        draftIds: documentId.map(id => `drafts.${id.replace(/^drafts\\./, '')}`),\n        result\n      };\n    }\n    \n    // Handle single document ID\n    // Ensure document ID doesn't already have 'drafts.' prefix\n    const baseDocId = documentId.replace(/^drafts\\./, '');\n    \n    // Create the unpublish action\n    const action = {\n      actionType: 'sanity.action.document.unpublish',\n      documentId: baseDocId\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Document ${baseDocId} unpublished successfully`,\n      draftId: `drafts.${baseDocId}`,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error unpublishing document:`, error);\n    throw new Error(`Failed to unpublish document: ${error.message}`);\n  }\n}\n\n/**\n * Creates one or more new documents in Sanity\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param documents - The document or array of documents to create\n * @param options - Additional options\n * @returns Result of the create operation\n */\nexport async function createDocument(\n  projectId: string, \n  dataset: string, \n  documents: Record<string, any> | Record<string, any>[],\n  options?: {\n    ifExists?: 'fail' | 'ignore'\n  }\n): Promise<{\n  success: boolean;\n  message: string;\n  documentId?: string;\n  documentIds?: string[];\n  result: any;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Handle array of documents\n    if (Array.isArray(documents)) {\n      if (documents.length === 0) {\n        throw new Error('Empty array of documents provided');\n      }\n      \n      // Validate and prepare each document\n      const preparedDocs = documents.map(doc => {\n        // Ensure document has _type\n        if (!doc._type) {\n          throw new Error('Document must have a _type field');\n        }\n        \n        // If document has _id, make sure it's properly formatted\n        if (doc._id && !doc._id.startsWith('drafts.')) {\n          return { ...doc, _id: `drafts.${doc._id}` };\n        }\n        \n        return doc;\n      });\n      \n      // Create documents based on options\n      const transaction = client.transaction();\n      \n      for (const doc of preparedDocs) {\n        if (options?.ifExists === 'ignore' && doc._id) {\n          transaction.createIfNotExists(doc as IdentifiedSanityDocumentStub<Record<string, any>>);\n        } else {\n          transaction.create(doc as SanityDocumentStub<{ _type: string }>);\n        }\n      }\n      \n      // Commit all document creations at once\n      const results = await transaction.commit();\n      \n      return {\n        success: true,\n        message: `${preparedDocs.length} documents created successfully`,\n        documentIds: results.results.map((res: any) => res.id),\n        result: results\n      };\n    }\n    \n    // Handle single document\n    const document = documents;\n    \n    // Ensure document has _type\n    if (!document._type) {\n      throw new Error('Document must have a _type field');\n    }\n    \n    // If document has _id, make sure it's properly formatted\n    if (document._id && !document._id.startsWith('drafts.')) {\n      document._id = `drafts.${document._id}`;\n    }\n    \n    let result;\n    \n    // Handle ifExists option\n    if (options?.ifExists === 'ignore' && document._id) {\n      // Use createIfNotExists if we want to ignore existing docs\n      result = await client.createIfNotExists(document as IdentifiedSanityDocumentStub<Record<string, any>>);\n    } else {\n      // Default behavior - just create\n      result = await client.create(document as SanityDocumentStub<{ _type: string }>);\n    }\n    \n    return {\n      success: true,\n      message: `Document created successfully with ID: ${result._id}`,\n      documentId: result._id,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error creating document:`, error);\n    throw new Error(`Failed to create document: ${error.message}`);\n  }\n}\n\n/**\n * Edits one or more existing documents with patches\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param documentId - The document ID or array of IDs to edit\n * @param patch - The patch operations to apply to each document\n * @returns Result of the edit operation\n */\nexport async function editDocument(\n  projectId: string, \n  dataset: string, \n  documentId: string | string[], \n  patch: Record<string, any>\n): Promise<{\n  success: boolean;\n  message: string;\n  documentId?: string;\n  documentIds?: string[];\n  result: any;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Handle array of document IDs\n    if (Array.isArray(documentId)) {\n      const result = await editMultipleDocuments(client, documentId, patch);\n      \n      return {\n        success: true,\n        message: `Edited ${documentId.length} documents successfully`,\n        documentIds: documentId.map(id => normalizeDraftId(id)),\n        result\n      };\n    }\n    \n    // Handle single document ID\n    const draftId = normalizeDraftId(documentId);\n    const result = await editSingleDocument(client, documentId, patch);\n    \n    return {\n      success: true,\n      message: `Document ${draftId} edited successfully`,\n      documentId: draftId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error editing document:`, error);\n    throw new Error(`Failed to edit document: ${error.message}`);\n  }\n}\n\n/**\n * Deletes one or more documents and optionally their drafts\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param documentId - The document ID or array of IDs to delete\n * @param options - Additional options\n * @returns Result of the delete operation\n */\nexport async function deleteDocument(\n  projectId: string, \n  dataset: string, \n  documentId: string | string[],\n  options?: {\n    includeDrafts?: string[];\n    purge?: boolean;\n  }\n): Promise<{\n  success: boolean;\n  message: string;\n  documentId?: string;\n  documentIds?: string[];\n  result: any;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Handle array of document IDs\n    if (Array.isArray(documentId)) {\n      if (documentId.length === 0) {\n        throw new Error('Empty array of document IDs provided');\n      }\n      \n      // Process each document ID\n      const transaction = client.transaction();\n      const processedIds = [];\n      \n      for (const id of documentId) {\n        // Ensure document ID doesn't already have 'drafts.' prefix\n        const baseDocId = id.replace(/^drafts\\./, '');\n        const draftId = `drafts.${baseDocId}`;\n        \n        // Delete the published document\n        transaction.delete(baseDocId);\n        \n        // Delete the draft document\n        transaction.delete(draftId);\n        \n        processedIds.push(baseDocId);\n      }\n      \n      // Delete any additional draft IDs specified\n      if (options?.includeDrafts && options.includeDrafts.length > 0) {\n        options.includeDrafts.forEach(id => {\n          transaction.delete(id);\n        });\n      }\n      \n      // Commit the transaction\n      const result = await transaction.commit({\n        // If purge is true, completely remove document from history\n        visibility: options?.purge ? 'async' : 'sync'\n      });\n      \n      return {\n        success: true,\n        message: `${processedIds.length} documents deleted successfully`,\n        documentIds: processedIds,\n        result\n      };\n    }\n    \n    // Handle single document ID\n    // Ensure document ID doesn't already have 'drafts.' prefix\n    const baseDocId = documentId.replace(/^drafts\\./, '');\n    const draftId = `drafts.${baseDocId}`;\n    \n    // Start a transaction\n    const transaction = client.transaction();\n    \n    // Delete the published document\n    transaction.delete(baseDocId);\n    \n    // Delete the draft document\n    transaction.delete(draftId);\n    \n    // Delete any additional draft IDs specified\n    if (options?.includeDrafts && options.includeDrafts.length > 0) {\n      options.includeDrafts.forEach(id => {\n        transaction.delete(id);\n      });\n    }\n    \n    // Commit the transaction\n    const result = await transaction.commit({\n      // If purge is true, completely remove from history\n      visibility: options?.purge ? 'async' : 'sync'\n    });\n    \n    return {\n      success: true,\n      message: `Document ${baseDocId} deleted successfully`,\n      documentId: baseDocId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error deleting document:`, error);\n    throw new Error(`Failed to delete document: ${error.message}`);\n  }\n}\n\n/**\n * Replaces one or more existing draft documents\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param documents - The replacement document or array of documents\n * @returns Result of the replace operation\n */\nexport async function replaceDraftDocument(\n  projectId: string, \n  dataset: string, \n  documents: Record<string, any> | Record<string, any>[]\n): Promise<{\n  success: boolean;\n  message: string;\n  documentId?: string;\n  documentIds?: string[];\n  result: any;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Handle array of documents\n    if (Array.isArray(documents)) {\n      if (documents.length === 0) {\n        throw new Error('Empty array of documents provided');\n      }\n      \n      // Validate and prepare each document\n      const preparedDocs = documents.map(doc => {\n        // Ensure document has _type and _id\n        if (!doc._type) {\n          throw new Error('Document must have a _type field');\n        }\n        \n        if (!doc._id) {\n          throw new Error('Document must have an _id field to replace');\n        }\n        \n        // Ensure document ID is a draft\n        if (!doc._id.startsWith('drafts.')) {\n          return { ...doc, _id: `drafts.${doc._id}` };\n        }\n        \n        return doc;\n      });\n      \n      // Replace documents in a single transaction\n      const transaction = client.transaction();\n      \n      for (const doc of preparedDocs) {\n        transaction.createOrReplace(doc as IdentifiedSanityDocumentStub<Record<string, any>>);\n      }\n      \n      const results = await transaction.commit();\n      \n      return {\n        success: true,\n        message: `${preparedDocs.length} draft documents replaced successfully`,\n        documentIds: preparedDocs.map(doc => doc._id),\n        result: results\n      };\n    }\n    \n    // Handle single document\n    const document = documents;\n    \n    // Ensure document has required fields\n    if (!document._type) {\n      throw new Error('Document must have a _type field');\n    }\n    \n    if (!document._id) {\n      throw new Error('Document must have an _id field to replace');\n    }\n    \n    // Ensure document ID is a draft\n    if (!document._id.startsWith('drafts.')) {\n      document._id = `drafts.${document._id}`;\n    }\n    \n    // Replace the document\n    const result = await client.createOrReplace(document as IdentifiedSanityDocumentStub<Record<string, any>>);\n    \n    return {\n      success: true,\n      message: `Draft document ${document._id} replaced successfully`,\n      documentId: document._id,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error replacing draft document:`, error);\n    throw new Error(`Failed to replace draft document: ${error.message}`);\n  }\n}\n\n/**\n * Edits a single document with the given patch\n * \n * @param client - Sanity client\n * @param documentId - The document ID to edit\n * @param patch - The patch operations to apply\n * @returns Result of the edit operation\n */\nasync function editSingleDocument(\n  client: any, \n  documentId: string, \n  patch: Record<string, any>\n): Promise<any> {\n  const draftId = normalizeDraftId(documentId);\n  \n  // Create a patch\n  const transaction = client.patch(draftId);\n  \n  // Apply all patch operations\n  applyPatchOperations(patch, transaction);\n  \n  // Commit the patch\n  return await transaction.commit();\n}\n\n/**\n * Edits multiple documents with the given patch\n * \n * @param client - Sanity client\n * @param documentIds - Array of document IDs to edit\n * @param patch - The patch operations to apply to each document\n * @returns Result of the edit operation\n */\nasync function editMultipleDocuments(\n  client: any, \n  documentIds: string[], \n  patch: Record<string, any>\n): Promise<any> {\n  if (documentIds.length === 0) {\n    throw new Error('Empty array of document IDs provided');\n  }\n  \n  // Process each document ID\n  const transaction = client.transaction();\n  \n  for (const id of documentIds) {\n    // Ensure ID points to a draft document\n    const draftId = normalizeDraftId(id);\n    \n    // Create a patch for each document\n    const patchOps = client.patch(draftId);\n    \n    // Apply all patch operations\n    applyPatchOperations(patch, patchOps);\n    \n    // Add the patch to the transaction\n    transaction.patch(patchOps);\n  }\n  \n  // Commit all patches at once\n  return await transaction.commit();\n}\n\n/**\n * Creates a version document for a single document\n * \n * @param client - Sanity client\n * @param releaseId - ID of the release\n * @param documentId - ID of the document\n * @param content - Optional content to use instead of the document's content\n * @returns The created version document\n */\nasync function createSingleDocumentVersion(\n  client: any,\n  releaseId: string,\n  documentId: string,\n  content?: Record<string, any>\n): Promise<any> {\n  const baseDocId = normalizeBaseDocId(documentId);\n  \n  // Get document content\n  const documentContent = await getDocumentContent(client, documentId, content);\n  \n  // Create version document\n  const versionDoc = {\n    _type: 'release.version',\n    _id: `release.version.${releaseId}.${baseDocId}`,\n    releaseId,\n    documentId: baseDocId,\n    content: content || documentContent\n  };\n  \n  // Create the version\n  return await client.create(versionDoc);\n}\n\n/**\n * Creates document versions in a specific release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to add the document version to\n * @param documentId - ID or array of IDs of the document(s) to create a version of\n * @param content - Optional content to use for the version\n * @returns Result of the create version operation\n */\nexport async function createDocumentVersion(\n  projectId: string, \n  dataset: string, \n  releaseId: string, \n  documentId: string | string[],\n  content?: Record<string, any>\n): Promise<{\n  success: boolean;\n  message: string;\n  versionId?: string;\n  versionIds?: string[];\n  result: any;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Handle array of document IDs\n    if (Array.isArray(documentId)) {\n      if (documentId.length === 0) {\n        throw new Error('Empty array of document IDs provided');\n      }\n      \n      const versionIds = [];\n      const results = [];\n      \n      // Process each document ID\n      for (const id of documentId) {\n        const result = await createSingleDocumentVersion(client, releaseId, id, content);\n        versionIds.push(result._id);\n        results.push(result);\n      }\n      \n      return {\n        success: true,\n        message: `Created ${versionIds.length} document versions for release ${releaseId}`,\n        versionIds,\n        result: results\n      };\n    }\n    \n    // Handle single document ID\n    const result = await createSingleDocumentVersion(client, releaseId, documentId, content);\n    \n    return {\n      success: true,\n      message: `Document version created for ${normalizeBaseDocId(documentId)} in release ${releaseId}`,\n      versionId: result._id,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error creating document version:`, error);\n    throw new Error(`Failed to create document version: ${error.message}`);\n  }\n}\n\n/**\n * Discards one or more specific versions of documents\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param versionId - ID or array of IDs of the version(s) to discard\n * @param options - Additional options\n * @returns Result of the discard operation\n */\nexport async function discardDocumentVersion(\n  projectId: string, \n  dataset: string, \n  versionId: string | string[],\n  options?: {\n    purge?: boolean;\n  }\n): Promise<{\n  success: boolean;\n  message: string;\n  versionId?: string;\n  versionIds?: string[];\n  result: any;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Handle array of version IDs\n    if (Array.isArray(versionId)) {\n      if (versionId.length === 0) {\n        throw new Error('Empty array of version IDs provided');\n      }\n      \n      // Use a transaction to delete all versions at once\n      const transaction = client.transaction();\n      \n      for (const id of versionId) {\n        transaction.delete(id);\n      }\n      \n      // Commit with purge option if specified\n      const result = await transaction.commit({\n        visibility: options?.purge ? 'async' : 'sync'\n      });\n      \n      return {\n        success: true,\n        message: `Discarded ${versionId.length} document versions`,\n        versionIds: versionId,\n        result\n      };\n    }\n    \n    // Handle single version ID\n    const result = await client.delete(versionId, {\n      // If purge is true, completely remove from history\n      visibility: options?.purge ? 'async' : 'sync'\n    });\n    \n    return {\n      success: true,\n      message: `Document version ${versionId} discarded successfully`,\n      versionId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error discarding document version:`, error);\n    throw new Error(`Failed to discard document version: ${error.message}`);\n  }\n}\n\n/**\n * Marks one or more documents for unpublishing when a release is published\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release\n * @param documentId - ID or array of IDs of the document(s) to unpublish\n * @returns Result of the unpublish with release operation\n */\nexport async function unpublishDocumentWithRelease(\n  projectId: string, \n  dataset: string, \n  releaseId: string,\n  documentId: string | string[]\n): Promise<{\n  success: boolean;\n  message: string;\n  documentId?: string;\n  documentIds?: string[];\n  result: any;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Handle array of document IDs\n    if (Array.isArray(documentId)) {\n      if (documentId.length === 0) {\n        throw new Error('Empty array of document IDs provided');\n      }\n      \n      const unpublishDocs = [];\n      const results = [];\n      \n      // Process each document ID\n      for (const id of documentId) {\n        // Ensure document ID doesn't already have 'drafts.' prefix\n        const baseDocId = id.replace(/^drafts\\./, '');\n        \n        // Create unpublish document\n        const unpublishDoc = {\n          _type: 'release.unpublish',\n          _id: `release.unpublish.${releaseId}.${baseDocId}`,\n          releaseId,\n          documentId: baseDocId\n        };\n        \n        // Create the unpublish record\n        const result = await client.create(unpublishDoc);\n        unpublishDocs.push(baseDocId);\n        results.push(result);\n      }\n      \n      return {\n        success: true,\n        message: `Marked ${unpublishDocs.length} documents for unpublishing with release ${releaseId}`,\n        documentIds: unpublishDocs,\n        result: results\n      };\n    }\n    \n    // Handle single document ID\n    // Ensure document ID doesn't already have 'drafts.' prefix\n    const baseDocId = documentId.replace(/^drafts\\./, '');\n    \n    // Create unpublish document\n    const unpublishDoc = {\n      _type: 'release.unpublish',\n      _id: `release.unpublish.${releaseId}.${baseDocId}`,\n      releaseId,\n      documentId: baseDocId\n    };\n    \n    // Create the unpublish record\n    const result = await client.create(unpublishDoc);\n    \n    return {\n      success: true,\n      message: `Document ${baseDocId} marked for unpublishing with release ${releaseId}`,\n      documentId: baseDocId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error marking document for unpublishing:`, error);\n    throw new Error(`Failed to mark document for unpublishing: ${error.message}`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/controllers/embeddings.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sanityClient' is assigned a value but never used.","line":14,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":15},{"ruleId":"complexity","severity":2,"message":"Async function 'listEmbeddingsIndices' has a complexity of 12. Maximum allowed is 10.","line":29,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":76,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Async function 'semanticSearch' has a complexity of 18. Maximum allowed is 10.","line":85,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":169,"endColumn":2},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 16 to the 10 allowed.","line":85,"column":23,"nodeType":null,"messageId":"refactorFunction","endLine":85,"endColumn":37}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Embeddings controller for semantic search functionality\n */\nimport config from '../config/config.js';\nimport { createClient } from '@sanity/client';\nimport { EmbeddingIndex, SearchOptions, SearchResponse } from '../types/index.js';\n\n// Initialize Sanity client only if project ID is available\nconst projectId = config.projectId || process.env.SANITY_PROJECT_ID;\nconst dataset = config.dataset || process.env.SANITY_DATASET;\n\nlet sanityClient;\nif (projectId) {\n  sanityClient = createClient({\n    projectId,\n    dataset,\n    apiVersion: config.apiVersion,\n    token: config.sanityToken,\n    useCdn: false\n  });\n}\n\n/**\n * Lists all embeddings indices for a dataset\n * \n * @param options - Options for listing embeddings indices\n * @returns Promise with array of embeddings indices\n */\nexport async function listEmbeddingsIndices({\n  projectId = config.projectId || process.env.SANITY_PROJECT_ID,\n  dataset = config.dataset || process.env.SANITY_DATASET\n} = {}): Promise<EmbeddingIndex[]> {\n  try {\n    // Ensure we have the necessary info\n    if (!projectId || !dataset) {\n      throw new Error(\"Project ID and Dataset name are required. Please set SANITY_PROJECT_ID and SANITY_DATASET in your environment variables or provide them as parameters.\");\n    }\n\n    // Validate token exists\n    if (!config.sanityToken) {\n      throw new Error(\"SANITY_TOKEN is missing. Please set a valid token in your .env file.\");\n    }\n\n    // API endpoint format for listing embeddings indices\n    // According to docs: https://www.sanity.io/docs/embeddings-index-http-api-reference\n    // The correct format is: https://<projectId>.api.sanity.io/vX/embeddings-index/<dataset-name>\n    const embeddingsEndpoint = `https://${projectId}.api.sanity.io/vX/embeddings-index/${dataset}`;\n    \n    // Request to embeddings API\n    const response = await fetch(embeddingsEndpoint, {\n      method: 'GET',\n      headers: {\n        'Accept': 'application/json',\n        'Authorization': `Bearer ${config.sanityToken}`\n      }\n    });\n\n    if (!response.ok) {\n      // Handle specific error cases with helpful messages\n      if (response.status === 401 || response.status === 403) {\n        throw new Error(\"Authentication failed: Your Sanity token is invalid or doesn't have access to embeddings.\");\n      } else if (response.status === 404) {\n        throw new Error(`No embeddings indices found for dataset '${dataset}'. You may need to create one first.`);\n      } else {\n        const errorText = await response.text();\n        throw new Error(`API request failed with status ${response.status}: ${errorText}`);\n      }\n    }\n    \n    const indices = await response.json() as EmbeddingIndex[];\n    return indices;\n  } catch (error) {\n    console.error(`Error listing embeddings indices:`, error);\n    throw new Error(`Failed to list embeddings indices: ${error instanceof Error ? error.message : String(error)}`);\n  }\n}\n\n/**\n * Performs semantic search on Sanity documentation and guides using embeddings\n * \n * @param query - Natural language query to search for semantically similar content\n * @param options - Additional search options\n * @returns Promise with search results containing hits and total properties\n */\nexport async function semanticSearch(query: string, { \n  indexName,\n  maxResults = 10, \n  types = [],\n  projectId = config.projectId || process.env.SANITY_PROJECT_ID,\n  dataset = config.dataset || process.env.SANITY_DATASET\n}: SearchOptions = {} as SearchOptions): Promise<SearchResponse> {\n  try {\n    // Ensure we have the necessary info\n    if (!query) {\n      throw new Error(\"Query parameter is required for semantic search\");\n    }\n    \n    if (!indexName) {\n      throw new Error(\"indexName parameter is required for semantic search. Use listEmbeddingsIndices to get available indices.\");\n    }\n    \n    if (!projectId || !dataset) {\n      throw new Error(\"Project ID and Dataset name are required. Please set SANITY_PROJECT_ID and SANITY_DATASET in your environment variables or provide them as parameters.\");\n    }\n\n    // Validate token exists\n    if (!config.sanityToken) {\n      throw new Error(\"SANITY_TOKEN is missing. Please set a valid token in your .env file.\");\n    }\n\n    // According to docs: https://www.sanity.io/docs/embeddings-index-http-api-reference \n    // API endpoint format for querying an embeddings index is:\n    // https://<projectId>.api.sanity.io/vX/embeddings-index/query/<dataset-name>/<index-name>\n    const embeddingsEndpoint = `https://${projectId}.api.sanity.io/vX/embeddings-index/query/${dataset}/${indexName}`;\n    \n    // Request to embeddings API\n    const embeddingsResponse = await fetch(embeddingsEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n        'Authorization': `Bearer ${config.sanityToken}`\n      },\n      body: JSON.stringify({\n        query: query,\n        limit: maxResults,\n        filter: types && types.length > 0 ? `_type in [${types.map(t => `\"${t}\"`).join(',')}]` : undefined\n      })\n    });\n\n    if (!embeddingsResponse.ok) {\n      // Handle specific error cases with helpful messages\n      if (embeddingsResponse.status === 401 || embeddingsResponse.status === 403) {\n        throw new Error(\"Authentication failed: Your Sanity token is invalid or doesn't have access to embeddings.\");\n      } else if (embeddingsResponse.status === 404) {\n        throw new Error(`Embeddings index \"${indexName}\" not found. Use listEmbeddingsIndices to get available indices.`);\n      } else {\n        const errorText = await embeddingsResponse.text();\n        throw new Error(`API request failed with status ${embeddingsResponse.status}: ${errorText}`);\n      }\n    }\n    \n    const rawResults = await embeddingsResponse.json();\n    \n    // The API returns an array of results, not an object\n    // Transform to our expected format with hits and total properties for consistency\n    if (Array.isArray(rawResults)) {\n      return {\n        hits: rawResults,\n        total: rawResults.length\n      };\n    }\n    \n    // If for some reason we get an object with hits already, just return it\n    if (rawResults.hits) {\n      return rawResults as SearchResponse;\n    }\n    \n    // If we somehow got an empty response or invalid format\n    return { \n      hits: [], \n      total: 0 \n    };\n  } catch (error) {\n    // Provide a helpful error message with additional context\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(`Failed to perform semantic search: ${errorMessage}`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/controllers/groq.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WebSocket' is defined but never used.","line":1,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":1,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used.","line":4,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SanityClient' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[883,886],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[883,886],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[952,955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[952,955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2380,2383],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2380,2383],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2394,2397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2394,2397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is assigned a value but never used.","line":109,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":109,"endColumn":37},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":127,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":127,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[3788,3968],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4411,4414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4411,4414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 11 to the 10 allowed.","line":160,"column":10,"nodeType":null,"messageId":"refactorFunction","endLine":160,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4900,4903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4900,4903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4906,4909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4906,4909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6003,6006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6003,6006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":202,"column":34,"nodeType":"Literal","endLine":202,"endColumn":69},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":328,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":328,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12652,12655],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12652,12655],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WebSocket } from 'ws';\nimport { createSanityClient } from '../utils/sanityClient.js';\nimport { portableTextToMarkdown } from '../utils/portableText.js';\nimport config from '../config/config.js';\nimport { SanityClient } from '@sanity/client';\nimport { SubscribeOptions } from '../types/index.js';\n\ninterface Subscription {\n  unsubscribe: () => void;\n}\n\n// Map of active subscriptions\nconst activeSubscriptions = new Map<string, Subscription>();\n\n/**\n * Executes GROQ queries to retrieve content\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param query - GROQ query to execute\n * @param params - Query parameters (if any)\n * @param verifyWithLLM - Whether to verify results with LLM (deprecated)\n * @returns Query results\n */\nexport async function query(\n  projectId: string, \n  dataset: string, \n  query: string, \n  params: Record<string, any> = {}, \n  verifyWithLLM: boolean = false\n): Promise<{\n  results: any;\n  verification?: {\n    performed: boolean;\n    originalCount: number;\n    verifiedCount: number;\n  };\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Execute the GROQ query\n    const results = await client.fetch(query, params);\n    \n    // If LLM verification is not needed, return the results directly\n    if (!verifyWithLLM) {\n      return {\n        results: processPortableTextFields(results)\n      };\n    }\n    \n    // If verification is requested, handle it\n    // This path is deprecated and will be removed in future versions\n    const verifiedResults = await verifyResults(results);\n    \n    return {\n      results: processPortableTextFields(verifiedResults.results),\n      verification: {\n        performed: true,\n        originalCount: Array.isArray(results) ? results.length : 1,\n        verifiedCount: Array.isArray(verifiedResults.results) ? verifiedResults.results.length : 1\n      }\n    };\n  } catch (error) {\n    console.error('Error executing GROQ query:', error);\n    const errorMessage = error instanceof Error \n      ? error.message \n      : String(error);\n    throw new Error(`Failed to execute GROQ query: ${errorMessage}`);\n  }\n}\n\n// For backwards compatibility\nexport const searchContent = query;\n\n/**\n * Verifies results using an LLM\n * \n * @param results - Array of content items to verify\n * @returns Verified results\n */\nasync function verifyResults(results: any): Promise<any> {\n  // In a real implementation, this would call OpenAI API to verify content\n  // For now, this is a stub implementation that just returns the original results\n  \n  // If results is an array, process each item, otherwise process the single result\n  if (Array.isArray(results)) {\n    // In a real implementation, you would filter out irrelevant or inappropriate content here\n    return results;\n  } else {\n    // Handle single result case\n    return results;\n  }\n}\n\n/**\n * Subscribes to real-time updates for documents matching a query\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param query - GROQ query to listen to\n * @param options - Additional options\n * @returns Subscription details\n */\nexport async function subscribeToUpdates(\n  projectId: string,\n  dataset: string,\n  query: string,\n  options: Partial<SubscribeOptions> = {}\n): Promise<{\n  subscriptionId: string;\n  query: string;\n  message: string;\n}> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Create a subscription\n    const subscription = client.listen(query);\n    \n    // Generate a unique subscription ID\n    const subscriptionId = `sub_${Date.now()}_${Math.random().toString(36).substring(2, 12)}`;\n    \n    // Set up event handlers for the subscription\n    const sub = subscription.subscribe((update) => {\n      // Process the update event\n      console.log(`Document update for subscription ${subscriptionId}:`, {\n        documentId: update.documentId,\n        type: update.transition,\n        result: update.result\n      });\n      \n      // In a production implementation, you would send these updates to the client\n      // e.g., via WebSockets, Server-Sent Events, or a notification system\n    });\n    \n    // Store the subscription in the active subscriptions map\n    activeSubscriptions.set(subscriptionId, sub);\n    \n    return {\n      subscriptionId,\n      query,\n      message: `Successfully subscribed to updates for query: ${query}`\n    };\n  } catch (error: any) {\n    console.error(`Error setting up subscription:`, error);\n    const errorMessage = error instanceof Error \n      ? error.message \n      : String(error);\n    throw new Error(`Failed to subscribe to updates: ${errorMessage}`);\n  }\n}\n\n/**\n * Helper function to convert Portable Text fields to Markdown\n * \n * @param data - Data containing potential Portable Text fields\n * @returns Processed data with Portable Text converted to Markdown\n */\nfunction processPortableTextFields(data: any): any {\n  // Handle array of results\n  if (Array.isArray(data)) {\n    return data.map(item => processPortableTextFields(item));\n  }\n  \n  // Handle single result (must be an object)\n  if (data && typeof data === 'object') {\n    // Create a shallow copy to avoid mutating the original\n    const result = { ...data };\n    \n    // Process each field in the object\n    for (const [key, value] of Object.entries(result)) {\n      // If it's an array, check if it's Portable Text\n      if (Array.isArray(value) && value.length > 0 && value[0]?._type === 'block') {\n        // Convert Portable Text to Markdown\n        result[key] = portableTextToMarkdown(value);\n      }\n      // If it's an object, process it recursively\n      else if (value && typeof value === 'object') {\n        result[key] = processPortableTextFields(value);\n      }\n    }\n    \n    return result;\n  }\n  \n  // Return primitives as-is\n  return data;\n}\n\n/**\n * Fetches the GROQ specification from the Sanity documentation\n * \n * @returns The GROQ specification\n */\nexport async function getGroqSpecification(): Promise<{\n  specification: any;\n  source: string;\n}> {\n  try {\n    // Fetch the GROQ specification from the Sanity documentation\n    const response = await fetch(\"https://sanity-io.github.io/GROQ/\");\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch GROQ specification, status: ${response.status}`);\n    }\n    \n    return {\n      specification: {\n        name: \"GROQ\",\n        version: \"1.0\",\n        description: \"GROQ (Graph-Relational Object Queries) is a query language for JSON-like data structures that enables you to filter and join data from multiple collections without explicit joins.\",\n        coreFeatures: [\n          \"Filtering with predicates and operators\",\n          \"Projections to shape the returned data\",\n          \"Joins across documents without explicit join syntax\",\n          \"Aggregation and grouping\",\n          \"Ordering and slicing results\"\n        ],\n        queryStructure: [\n          {\n            name: \"Dataset selector\",\n            description: \"Select the dataset to query, defaults to the current dataset\",\n            syntax: \"*\",\n            example: \"*[_type == 'post']\"\n          },\n          {\n            name: \"Filter\",\n            description: \"Filter documents using conditions inside square brackets\",\n            syntax: \"[<condition>]\",\n            example: \"*[_type == 'post' && publishedAt > '2023-01-01']\"\n          },\n          {\n            name: \"Projection\",\n            description: \"Shape the returned data using a projection object\",\n            syntax: \"{<field>, <field2>}\",\n            example: \"*[_type == 'post']{title, body, author}\"\n          },\n          {\n            name: \"References\",\n            description: \"Follow references to other documents\",\n            syntax: \"<reference>->\",\n            example: \"*[_type == 'post']{title, 'authorName': author->name}\"\n          },\n          {\n            name: \"Ordering\",\n            description: \"Order results\",\n            syntax: \"order(<field> [asc|desc])\",\n            example: \"*[_type == 'post'] | order(publishedAt desc)\"\n          },\n          {\n            name: \"Slicing\",\n            description: \"Limit the number of results\",\n            syntax: \"[<start>...<end>]\",\n            example: \"*[_type == 'post'] | order(publishedAt desc)[0...10]\"\n          }\n        ],\n        operators: [\n          { name: \"==\", description: \"Equal to\", example: \"_type == 'post'\" },\n          { name: \"!=\", description: \"Not equal to\", example: \"_type != 'page'\" },\n          { name: \">\", description: \"Greater than\", example: \"publishedAt > '2023-01-01'\" },\n          { name: \">=\", description: \"Greater than or equal to\", example: \"views >= 100\" },\n          { name: \"<\", description: \"Less than\", example: \"price < 50\" },\n          { name: \"<=\", description: \"Less than or equal to\", example: \"stock <= 10\" },\n          { name: \"in\", description: \"Check if value exists in an array\", example: \"'fiction' in categories\" },\n          { name: \"match\", description: \"Check if string matches a pattern\", example: \"title match 'coffee*'\" },\n          { name: \"&&\", description: \"Logical AND\", example: \"_type == 'post' && published == true\" },\n          { name: \"||\", description: \"Logical OR\", example: \"_type == 'post' || _type == 'article'\" },\n          { name: \"!\", description: \"Logical NOT\", example: \"!draft\" },\n          { name: \"?\", description: \"Conditional selector (if condition is met)\", example: \"featured ? title : null\" },\n          { name: \"count()\", description: \"Count items\", example: \"count(*[_type == 'post'])\" },\n          { name: \"defined()\", description: \"Check if field is defined\", example: \"defined(imageUrl)\" },\n          { name: \"references()\", description: \"Check if document references another\", example: \"references('doc-id')\" }\n        ],\n        examples: [\n          {\n            description: \"Get all documents of type 'post'\",\n            query: \"*[_type == 'post']\"\n          },\n          {\n            description: \"Get the title of all posts\",\n            query: \"*[_type == 'post'].title\"\n          },\n          {\n            description: \"Get posts with their authors\",\n            query: \"*[_type == 'post']{title, 'authorName': author->name}\"\n          },\n          {\n            description: \"Filter posts by published date\",\n            query: \"*[_type == 'post' && publishedAt > '2023-01-01']\"\n          },\n          {\n            description: \"Get the 10 latest posts\",\n            query: \"*[_type == 'post'] | order(publishedAt desc)[0...10]\"\n          },\n          {\n            description: \"Count posts by category\",\n            query: \"*[_type == 'category']{name, 'count': count(*[_type == 'post' && references(^._id)])}\"\n          },\n          {\n            description: \"Get posts with specific fields and follow author reference\",\n            query: \"*[_type == 'post']{title, body, 'author': author->{name, 'imageUrl': image.asset->url}}\"\n          },\n          {\n            description: \"Full-text search in post titles\",\n            query: \"*[_type == 'post' && title match 'design*']\"\n          }\n        ],\n        functions: [\n          { name: \"count()\", description: \"Counts the number of items in an array\", example: \"count(*[_type == 'post'])\" },\n          { name: \"defined()\", description: \"Checks if a property is defined\", example: \"*[_type == 'post' && defined(imageUrl)]\" },\n          { name: \"references()\", description: \"Checks if a document references another\", example: \"*[_type == 'post' && references('author-id')]\" },\n          { name: \"order()\", description: \"Orders results by a property\", example: \"*[_type == 'post'] | order(publishedAt desc)\" },\n          { name: \"now()\", description: \"Returns the current datetime\", example: \"*[_type == 'post' && publishedAt < now()]\" },\n          { name: \"coalesce()\", description: \"Returns the first non-null value\", example: \"coalesce(subtitle, title, 'Untitled')\" },\n          { name: \"select()\", description: \"Selects value based on a condition\", example: \"select(_type == 'post' => title, _type == 'page' => heading, 'Unknown')\" },\n          { name: \"length()\", description: \"Returns the length of a string or array\", example: \"*[_type == 'post' && length(tags) > 3]\" }\n        ],\n        resources: [\n          { name: \"GROQ documentation\", url: \"https://www.sanity.io/docs/groq\" },\n          { name: \"GROQ cheat sheet\", url: \"https://www.sanity.io/docs/query-cheat-sheet\" },\n          { name: \"Learn GROQ\", url: \"https://groq.dev/\" },\n          { name: \"GROQ specification\", url: \"https://sanity-io.github.io/GROQ/\" }\n        ]\n      },\n      source: \"https://sanity-io.github.io/GROQ/\"\n    };\n  } catch (error: any) {\n    console.error(\"Error fetching GROQ specification:\", error);\n    const errorMessage = error instanceof Error \n      ? error.message \n      : String(error);\n    throw new Error(`Failed to get GROQ specification: ${errorMessage}`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/controllers/mutate.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[220,223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[220,223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[293,296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[293,296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[368,371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[368,371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[497,500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[497,500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[564,567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[564,567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[666,669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[666,669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[728,731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[728,731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[980,983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[980,983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[986,989],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[986,989],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used.","line":26,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1189,1192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1189,1192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1261,1264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1261,1264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1529,1532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1529,1532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1649,1652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1649,1652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1833,1836],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1833,1836],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1963,1966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1963,1966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2003,2006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2003,2006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2136,2139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2136,2139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2144,2147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2144,2147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2373,2376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2373,2376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2404,2407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2404,2407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2444,2447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2444,2447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2577,2580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2577,2580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2585,2588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2585,2588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4905,4908],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4905,4908],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5620,5623],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5620,5623],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":206,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5661,5664],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5661,5664],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6077,6080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6077,6080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6951,6954],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6951,6954],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":304,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":304,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8227,8230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8227,8230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8780,8783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8780,8783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":355,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9779,9782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9779,9782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":356,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":356,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9814,9817],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9814,9817],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":409,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11338,11341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11338,11341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":424,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11747,11750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11747,11750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":424,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11769,11772],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11769,11772],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":426,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":426,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11857,11860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11857,11860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":37,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSanityClient } from '../utils/sanityClient.js';\nimport { SanityClient } from '@sanity/client';\n\n// Define interface for Sanity transaction\ninterface SanityTransaction {\n  create: (document: Record<string, any>) => SanityTransaction;\n  createOrReplace: (document: Record<string, any>) => SanityTransaction;\n  createIfNotExists: (document: Record<string, any>) => SanityTransaction;\n  delete: (idOrQuery: string) => SanityTransaction;\n  patch: (patchObj: SanityPatch | Record<string, any>) => SanityTransaction;\n  commit: () => Promise<Record<string, any>>;\n}\n\n// Define interface for Sanity patch\ninterface SanityPatch {\n  set: (fields: Record<string, any>) => SanityPatch;\n  setIfMissing: (fields: Record<string, any>) => SanityPatch;\n  unset: (fields: string[]) => SanityPatch;\n  inc: (fields: Record<string, number>) => SanityPatch;\n  dec: (fields: Record<string, number>) => SanityPatch;\n  insert: (position: 'before' | 'after' | 'replace', path: string, items: any | any[]) => SanityPatch;\n  ifRevisionId: (revisionId: string) => SanityPatch;\n}\n\n// Define types for mutations\ninterface SanityDocumentStub<T extends { _type: string }> {\n  _type: string;\n  [key: string]: any;\n}\n\ninterface IdentifiedSanityDocumentStub<T extends Record<string, any>> extends SanityDocumentStub<T & { _type: string }> {\n  _id: string;\n}\n\nexport interface CreateMutation {\n  create: SanityDocumentStub<{ _type: string }>;\n}\n\nexport interface CreateOrReplaceMutation {\n  createOrReplace: IdentifiedSanityDocumentStub<Record<string, any>>;\n}\n\nexport interface CreateIfNotExistsMutation {\n  createIfNotExists: IdentifiedSanityDocumentStub<Record<string, any>>;\n}\n\nexport interface DeleteByIdMutation {\n  delete: {\n    id: string;\n  };\n}\n\nexport interface DeleteByQueryMutation {\n  delete: {\n    query: string;\n    params?: Record<string, any>;\n  };\n}\n\nexport interface PatchByIdMutation {\n  patch: {\n    id: string;\n    ifRevisionID?: string;\n    set?: Record<string, any>;\n    setIfMissing?: Record<string, any>;\n    unset?: string | string[];\n    inc?: Record<string, number>;\n    dec?: Record<string, number>;\n    insert?: {\n      items: any[] | any;\n      position: 'before' | 'after' | 'replace';\n      at: string;\n    };\n    diffMatchPatch?: Record<string, string>;\n  };\n}\n\nexport interface PatchByQueryMutation {\n  patch: {\n    query: string;\n    params?: Record<string, any>;\n    set?: Record<string, any>;\n    setIfMissing?: Record<string, any>;\n    unset?: string | string[];\n    inc?: Record<string, number>;\n    dec?: Record<string, number>;\n    insert?: {\n      items: any[] | any;\n      position: 'before' | 'after' | 'replace';\n      at: string;\n    };\n    diffMatchPatch?: Record<string, string>;\n  };\n}\n\nexport type Mutation = \n  | CreateMutation \n  | CreateOrReplaceMutation \n  | CreateIfNotExistsMutation \n  | DeleteByIdMutation \n  | DeleteByQueryMutation \n  | PatchByIdMutation \n  | PatchByQueryMutation;\n\n/**\n * Helper function to add create mutation to a transaction\n * \n * @param transaction - Sanity transaction\n * @param mutation - Create mutation\n */\nfunction addCreateMutation(\n  transaction: SanityTransaction, \n  mutation: CreateMutation\n): void {\n  transaction.create(mutation.create);\n}\n\n/**\n * Helper function to add createOrReplace mutation to a transaction\n * \n * @param transaction - Sanity transaction\n * @param mutation - CreateOrReplace mutation\n */\nfunction addCreateOrReplaceMutation(\n  transaction: SanityTransaction, \n  mutation: CreateOrReplaceMutation\n): void {\n  transaction.createOrReplace(mutation.createOrReplace);\n}\n\n/**\n * Helper function to add createIfNotExists mutation to a transaction\n * \n * @param transaction - Sanity transaction\n * @param mutation - CreateIfNotExists mutation\n */\nfunction addCreateIfNotExistsMutation(\n  transaction: SanityTransaction, \n  mutation: CreateIfNotExistsMutation\n): void {\n  transaction.createIfNotExists(mutation.createIfNotExists);\n}\n\n/**\n * Helper function to add delete mutation to a transaction\n * \n * @param transaction - Sanity transaction\n * @param mutation - Delete mutation (by ID or query)\n */\nfunction addDeleteMutation(\n  transaction: SanityTransaction, \n  mutation: DeleteByIdMutation | DeleteByQueryMutation\n): void {\n  if ('query' in mutation.delete) {\n    // Delete by query\n    transaction.delete(mutation.delete.query);\n  } else if ('id' in mutation.delete) {\n    // Delete by ID\n    transaction.delete(mutation.delete.id);\n  }\n}\n\n/**\n * Helper function to add patch mutation by ID to a transaction\n * \n * @param client - Sanity client\n * @param transaction - Sanity transaction\n * @param id - Document ID\n * @param ifRevisionID - Optional revision ID for optimistic locking\n * @param patchOperations - Operations to apply in the patch\n */\nfunction addPatchByIdMutation(\n  client: SanityClient,\n  transaction: SanityTransaction,\n  id: string,\n  ifRevisionID?: string,\n  patchOperations?: Record<string, any>\n): void {\n  if (!patchOperations) return;\n  \n  const patch = client.patch(id);\n  \n  // Apply optimistic locking if ifRevisionID is provided\n  if (ifRevisionID) {\n    patch.ifRevisionId(ifRevisionID);\n  }\n  \n  applyPatchOperationsToClient(patch, patchOperations);\n  \n  // Add the patch to the transaction\n  transaction.patch(patch);\n}\n\n/**\n * Helper function to add patch mutation by query to a transaction\n * \n * @param transaction - Sanity transaction\n * @param query - GROQ query string\n * @param params - Optional query parameters\n * @param patchOperations - Operations to apply in the patch\n */\nfunction addPatchByQueryMutation(\n  transaction: SanityTransaction,\n  query: string,\n  params?: Record<string, any>,\n  patchOperations?: Record<string, any>\n): void {\n  if (!patchOperations) return;\n  \n  transaction.patch({\n    query,\n    params,\n    ...constructPatchOperations(patchOperations)\n  });\n}\n\n/**\n * Helper function to apply patch operations to a Sanity patch client\n * \n * @param patch - Sanity patch client\n * @param patchOperations - Operations to apply\n */\nfunction applyPatchOperationsToClient(\n  patch: SanityPatch,\n  patchOperations: Record<string, any>\n): void {\n  // Apply patch operations in the correct order: set, setIfMissing, unset, inc, dec, insert\n  if (patchOperations.set) {\n    patch.set(patchOperations.set);\n  }\n  \n  if (patchOperations.setIfMissing) {\n    patch.setIfMissing(patchOperations.setIfMissing);\n  }\n  \n  if (patchOperations.unset) {\n    patch.unset(Array.isArray(patchOperations.unset) ? patchOperations.unset : [patchOperations.unset]);\n  }\n  \n  if (patchOperations.inc) {\n    patch.inc(patchOperations.inc);\n  }\n  \n  if (patchOperations.dec) {\n    patch.dec(patchOperations.dec);\n  }\n  \n  if (patchOperations.insert) {\n    applyInsertOperation(patch, patchOperations.insert);\n  }\n}\n\n/**\n * Helper function to apply insert operation to a patch\n * \n * @param patch - Sanity patch client\n * @param insertOp - Insert operation details\n */\nfunction applyInsertOperation(patch: SanityPatch, insertOp: any): void {\n  const { items, position, ...rest } = insertOp;\n  if (position === 'before') {\n    patch.insert('before', rest.at, items);\n  } else if (position === 'after') {\n    patch.insert('after', rest.at, items);\n  } else if (position === 'replace') {\n    patch.insert('replace', rest.at, items);\n  }\n}\n\n/**\n * Helper function to process a single mutation and add it to the transaction\n * \n * @param client - Sanity client\n * @param transaction - Sanity transaction\n * @param mutation - Mutation to process\n */\nfunction processMutation(\n  client: SanityClient,\n  transaction: SanityTransaction,\n  mutation: Mutation\n): void {\n  // Handle create mutation\n  if ('create' in mutation) {\n    addCreateMutation(transaction, mutation);\n  }\n  \n  // Handle createOrReplace mutation\n  if ('createOrReplace' in mutation) {\n    addCreateOrReplaceMutation(transaction, mutation);\n  }\n  \n  // Handle createIfNotExists mutation\n  if ('createIfNotExists' in mutation) {\n    addCreateIfNotExistsMutation(transaction, mutation);\n  }\n  \n  // Handle delete mutation\n  if ('delete' in mutation) {\n    addDeleteMutation(transaction, mutation);\n  }\n  \n  // Handle patch mutation\n  if ('patch' in mutation) {\n    const { id, query, params, ifRevisionID, ...patchOperations } = mutation.patch as any;\n    \n    if (query) {\n      // Patch by query\n      addPatchByQueryMutation(transaction, query, params, patchOperations);\n    } else if (id) {\n      // Patch by ID\n      addPatchByIdMutation(client, transaction, id, ifRevisionID, patchOperations);\n    }\n  }\n}\n\n/**\n * Helper function to retrieve documents for mutations\n * \n * @param client - Sanity client\n * @param mutations - Array of mutations\n * @returns Array of retrieved documents\n */\nasync function retrieveDocumentsForMutations(\n  client: SanityClient,\n  mutations: Mutation[]\n): Promise<any[]> {\n  return await Promise.all(mutations.map(async (mutation) => {\n    // Type guard for different mutation types\n    if ('create' in mutation) {\n      return client.getDocument(mutation.create._id);\n    } else if ('createOrReplace' in mutation) {\n      return client.getDocument(mutation.createOrReplace._id);\n    } else if ('createIfNotExists' in mutation) {\n      return client.getDocument(mutation.createIfNotExists._id);\n    } else if ('patch' in mutation) {\n      // Need to handle both patch by ID and patch by query\n      if ('id' in mutation.patch) {\n        return client.getDocument(mutation.patch.id);\n      } else if ('query' in mutation.patch) {\n        // For query-based patches we can't easily get the document\n        // without executing the query again\n        return null;\n      }\n    }\n    return null;\n  }));\n}\n\n/**\n * Interface for results returned by modifyDocuments\n */\ninterface MutateDocumentsResult {\n  success: boolean;\n  message: string;\n  result: Record<string, any>;\n  documents?: Record<string, any>[];\n}\n\n/**\n * Creates or updates documents using Sanity mutations\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param mutations - Array of mutation objects following Sanity mutation format\n * @param returnDocuments - Whether to return modified documents in response\n * @returns Result of the mutations operation\n */\nasync function modifyDocuments(\n  projectId: string, \n  dataset: string, \n  mutations: Mutation[],\n  returnDocuments: boolean = false\n): Promise<MutateDocumentsResult> {\n  try {\n    const client = createSanityClient(projectId, dataset);\n    \n    // Validate inputs\n    if (!mutations || !Array.isArray(mutations) || mutations.length === 0) {\n      throw new Error('At least one mutation is required');\n    }\n    \n    // Create a transaction\n    const transaction = client.transaction();\n    \n    // Process each mutation\n    mutations.forEach(mutation => {\n      processMutation(client, transaction, mutation);\n    });\n    \n    // Commit the transaction\n    const result = await transaction.commit();\n    \n    if (returnDocuments) {\n      const documents = await retrieveDocumentsForMutations(client, mutations);\n      \n      return {\n        success: true,\n        message: `Successfully applied ${mutations.length} mutations`,\n        result,\n        documents: documents.filter(Boolean)\n      };\n    } else {\n      return {\n        success: true,\n        message: `Successfully applied ${mutations.length} mutations`,\n        result\n      };\n    }\n  } catch (error: any) {\n    console.error(`Error modifying documents:`, error);\n    throw new Error(`Failed to modify documents: ${error.message}`);\n  }\n}\n\n// Export the refactored function\nexport { modifyDocuments };\n\n/**\n * Helper function to construct patch operations\n * \n * @param patch - Raw patch object with operations\n * @returns Formatted patch operations\n */\nfunction constructPatchOperations(patch: Record<string, any>): Record<string, any> {\n  // Extract operations from the patch object\n  const operations: Record<string, any> = {};\n  \n  // Handle 'set' operations\n  if (patch.set) {\n    operations.set = patch.set;\n  }\n  \n  // Handle 'setIfMissing' operations\n  if (patch.setIfMissing) {\n    operations.setIfMissing = patch.setIfMissing;\n  }\n  \n  // Handle 'unset' operations\n  if (patch.unset) {\n    operations.unset = Array.isArray(patch.unset) ? patch.unset : [patch.unset];\n  }\n  \n  // Handle 'inc' operations\n  if (patch.inc) {\n    operations.inc = patch.inc;\n  }\n  \n  // Handle 'dec' operations\n  if (patch.dec) {\n    operations.dec = patch.dec;\n  }\n  \n  // Handle 'insert' operations (for arrays)\n  if (patch.insert) {\n    operations.insert = patch.insert;\n  }\n  \n  // Handle 'diffMatchPatch' operations\n  if (patch.diffMatchPatch) {\n    operations.diffMatchPatch = patch.diffMatchPatch;\n  }\n  \n  return operations;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/controllers/projects.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2058,2061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2058,2061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3395,3398],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3395,3398],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { sanityApi } from '../utils/sanityClient.js';\n\ninterface Project {\n  id: string;\n  displayName: string;\n  studioHost?: string;\n  externalStudioHost?: string;\n  organizationId?: string;\n}\n\ninterface Organization {\n  organizationId: string;\n  organizationName: string;\n  projects: {\n    id: string;\n    displayName: string;\n    studioHost?: string;\n    externalStudioHost?: string;\n  }[];\n}\n\ninterface Studio {\n  type: 'sanity-hosted' | 'external';\n  url: string;\n}\n\ninterface StudiosResult {\n  studios: Studio[];\n  message?: string;\n}\n\n/**\n * List all organizations and their projects that the user has access to\n * \n * @returns Array of organizations with their projects\n */\nexport async function listOrganizationsAndProjects(): Promise<Organization[]> {\n  try {\n    // Fetch all projects\n    const projects = await sanityApi.listProjects() as Project[];\n    \n    // Group projects by organization\n    const orgMap = new Map<string | null, Organization>();\n    \n    // Add \"Personal Projects\" group for projects without organization\n    orgMap.set(null, {\n      organizationId: 'personal',\n      organizationName: 'Personal Projects',\n      projects: []\n    });\n    \n    // Group projects by organization\n    projects.forEach(project => {\n      const orgId = project.organizationId || null;\n      \n      if (!orgMap.has(orgId) && orgId !== null) {\n        orgMap.set(orgId, {\n          organizationId: orgId,\n          organizationName: `Organization ${orgId}`, // We don't have org names from the API\n          projects: []\n        });\n      }\n      \n      // Add project to the organization\n      const org = orgMap.get(orgId);\n      if (org) {\n        org.projects.push({\n          id: project.id,\n          displayName: project.displayName,\n          studioHost: project.studioHost,\n          externalStudioHost: project.externalStudioHost\n        });\n      }\n    });\n    \n    // Convert map to array\n    return Array.from(orgMap.values())\n      // Remove empty organizations\n      .filter(org => org.projects.length > 0);\n    \n  } catch (error: any) {\n    console.error('Error listing organizations and projects:', error);\n    throw new Error(`Failed to list organizations and projects: ${error.message}`);\n  }\n}\n\n/**\n * List all studios for a specific project\n * \n * @param projectId - Sanity project ID\n * @returns Array of studio URLs\n */\nexport async function listStudios(projectId: string): Promise<StudiosResult> {\n  try {\n    // Fetch all projects to find the one with matching ID\n    const projects = await sanityApi.listProjects() as Project[];\n    const project = projects.find(p => p.id === projectId);\n    \n    if (!project) {\n      throw new Error(`Project not found: ${projectId}`);\n    }\n    \n    const studios: Studio[] = [];\n    \n    // Add Sanity-hosted studio if available\n    if (project.studioHost) {\n      studios.push({\n        type: 'sanity-hosted',\n        url: `https://${project.studioHost}.sanity.studio/`\n      });\n    }\n    \n    // Add external studio if available\n    if (project.externalStudioHost) {\n      studios.push({\n        type: 'external',\n        url: project.externalStudioHost\n      });\n    }\n    \n    // If no studios found, include a note\n    if (studios.length === 0) {\n      return {\n        studios: [],\n        message: 'No hosted studio - Studio may be local only'\n      };\n    }\n    \n    return { studios };\n    \n  } catch (error: any) {\n    console.error(`Error listing studios for project ${projectId}:`, error);\n    throw new Error(`Failed to list studios: ${error.message}`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/controllers/releases.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async function 'createRelease' has a complexity of 14. Maximum allowed is 10.","line":37,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":97,"endColumn":2},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 11 to the 10 allowed.","line":37,"column":23,"nodeType":null,"messageId":"refactorFunction","endLine":37,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1646,1649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1646,1649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2663,2666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2663,2666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3885,3888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3885,3888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4589,4592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4589,4592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4664,4667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4664,4667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":170,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5696,5699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5696,5699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5833,5836],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5833,5836],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6705,6708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6705,6708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":227,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":227,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[7626,7709],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":238,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7879,7882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7879,7882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":262,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8570,8573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8570,8573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":290,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9406,9409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9406,9409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":309,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":309,"endColumn":19,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"warn"},"fix":{"range":[10338,10425],"text":""},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":319,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":319,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10577,10580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10577,10580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":362,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":362,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11844,11847],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11844,11847],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12291,12294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12291,12294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":402,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":402,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12887,12890],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12887,12890],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13828,13831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13828,13831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":451,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":451,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14244,14247],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14244,14247],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":466,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14587,14590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14587,14590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":495,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":495,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15730,15733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15730,15733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":514,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":514,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16209,16212],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16209,16212],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":543,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":543,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16937,16940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16937,16940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":555,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":555,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17340,17343],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17340,17343],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":582,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":582,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18219,18222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18219,18222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":607,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":607,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18897,18900],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18897,18900],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":630,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":630,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19438,19441],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19438,19441],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":652,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":652,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20005,20008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20005,20008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":673,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":673,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20499,20502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20499,20502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":695,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":695,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21037,21040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21037,21040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":716,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":716,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21522,21525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21522,21525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":738,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":738,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22082,22085],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22082,22085],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":759,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":759,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22573,22576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22573,22576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":781,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":781,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23115,23118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23115,23118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":802,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":802,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23597,23600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23597,23600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":35,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createSanityClient, sanityApi, isSufficientApiVersion } from '../utils/sanityClient.js';\nimport { normalizeBaseDocId, normalizeDocumentIds, createErrorResponse, getDocumentContent } from '../utils/documentHelpers.js';\nimport config from '../config/config.js';\n\n// Minimum API version required for Content Releases\nconst REQUIRED_API_VERSION = '2024-05-23';\n\n/**\n * Checks if the configured API version is sufficient for Content Releases\n * Throws an error if the version is too old\n */\nfunction validateApiVersion(): void {\n  // Skip validation for test environment (vi.mock will set this)\n  if (process.env.NODE_ENV === 'test') {\n    return;\n  }\n  \n  const currentVersion = config.apiVersion;\n  \n  if (!isSufficientApiVersion(currentVersion, REQUIRED_API_VERSION)) {\n    throw new Error(\n      `API version ${currentVersion} is outdated. Please update to version ${REQUIRED_API_VERSION} or later to use Content Releases. You can do this by updating your SANITY_API_VERSION in .env or config.`\n    );\n  }\n}\n\n/**\n * Creates a new content release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - Unique ID for the release\n * @param title - Display title for the release\n * @param options - Optional metadata for the release\n * @returns Result of creating the release\n */\nexport async function createRelease(\n  projectId: string, \n  dataset: string, \n  releaseId: string, \n  title?: string,\n  options?: {\n    description?: string;\n    releaseType?: 'asap' | 'scheduled';\n    intendedPublishAt?: string;\n  }\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Validate that scheduled releases have intendedPublishAt\n    if (options?.releaseType === 'scheduled' && !options?.intendedPublishAt) {\n      throw new Error('publishAt is required for scheduled releases');\n    }\n    \n    // Create the release action\n    const action = {\n      actionType: 'sanity.action.release.create',\n      releaseId,\n      metadata: {\n        title: title || `Release: ${releaseId}`,\n        ...(options?.description && { description: options.description }),\n        ...(options?.releaseType && { releaseType: options.releaseType }),\n        ...(options?.intendedPublishAt && { intendedPublishAt: options.intendedPublishAt })\n      }\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} created successfully`,\n      releaseId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error creating release ${releaseId}:`, error);\n    \n    // Check for common issues\n    if (error.message?.includes('API version')) {\n      throw new Error(`Failed to create release: Make sure you're using API version 2024-05-23 or later.`);\n    } else if (error.statusCode === 404 || error.message?.includes('not found')) {\n      throw new Error(`Failed to create release: The Content Releases feature might not be enabled for this project or the API token lacks permissions.`);\n    } else if (error.statusCode === 401 || error.statusCode === 403 || error.message?.includes('Not authorized')) {\n      throw new Error(`Failed to create release: Authentication failed. Check that your Sanity token has permission to create releases.`);\n    } else {\n      throw new Error(`Failed to create release: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Creates a version document action for a document in a release\n * \n * @param releaseId - ID of the release\n * @param documentId - ID of the document to create a version for\n * @param attributes - Document content/attributes\n * @returns The created action object\n */\nfunction createVersionAction(releaseId: string, documentId: string, attributes: Record<string, any>) {\n  const baseDocId = normalizeBaseDocId(documentId);\n  const versionId = `versions.${releaseId}.${baseDocId}`;\n  \n  return {\n    actionType: 'sanity.action.document.version.create',\n    publishedId: baseDocId,\n    attributes: {\n      ...attributes,\n      _id: versionId\n    }\n  };\n}\n\n/**\n * Processes a single document for adding to a release\n * \n * @param client - Sanity client\n * @param releaseId - ID of the release\n * @param documentId - ID of the document to process\n * @param content - Optional custom content\n * @returns Object containing the processed document's action, ID, and version ID\n * @throws Error if document is not found\n */\nasync function processDocumentForRelease(\n  client: any,\n  releaseId: string,\n  documentId: string,\n  content?: Record<string, any>\n) {\n  const baseDocId = normalizeBaseDocId(documentId);\n  \n  // Use provided content or fetch from Sanity\n  const attributes = content || await getDocumentContent(client, documentId);\n  \n  // Create version ID\n  const versionId = `versions.${releaseId}.${baseDocId}`;\n  \n  // Create the version action\n  const action = createVersionAction(releaseId, documentId, attributes);\n  \n  return {\n    action,\n    documentId: baseDocId,\n    versionId\n  };\n}\n\n/**\n * Adds a document or multiple documents to a content release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release\n * @param documentIds - ID or array of IDs of the document(s) to add to the release\n * @param content - Optional custom content to use for the document version\n * @returns Result of adding the document(s) to the release\n */\nexport async function addDocumentToRelease(\n  projectId: string, \n  dataset: string, \n  releaseId: string, \n  documentIds: string | string[], \n  content?: Record<string, any>\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  documentIds: string[];\n  versionIds: string[];\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Normalize document IDs\n    const parsedDocIds = normalizeDocumentIds(documentIds);\n    \n    // Process each document\n    const actions = [];\n    const versionIds = [];\n    const processedDocIds = [];\n    const errors: string[] = [];\n    \n    const client = createSanityClient(projectId, dataset);\n    \n    // Process each document ID individually\n    for (const documentId of parsedDocIds) {\n      try {\n        // Process the document and get its action\n        const { action, documentId: baseDocId, versionId } = await processDocumentForRelease(\n          client,\n          releaseId,\n          documentId,\n          content\n        );\n        \n        actions.push(action);\n        versionIds.push(versionId);\n        processedDocIds.push(baseDocId);\n      } catch (documentError: any) {\n        // Log and collect errors for individual documents\n        console.error(`Error processing document ${documentId}:`, documentError);\n        errors.push(`Document ID ${documentId}: ${documentError.message}`);\n      }\n    }\n    \n    // If no documents were processed successfully, throw an error with all collected error messages\n    if (processedDocIds.length === 0) {\n      throw new Error(`Failed to add any documents to release: ${errors.join('; ')}`);\n    }\n    \n    // Call the Actions API with all document actions\n    const result = await sanityApi.performActions(projectId, dataset, actions);\n    \n    // If we have both successful and failed documents, include that in the message\n    let message = `${processedDocIds.length} document(s) added to release ${releaseId} successfully`;\n    if (errors.length > 0) {\n      message += `. Warning: ${errors.length} document(s) could not be added`;\n      console.warn(`Some documents could not be added to release ${releaseId}:`, errors);\n    }\n    \n    return {\n      success: true,\n      message,\n      releaseId,\n      documentIds: processedDocIds,\n      versionIds,\n      result\n    };\n  } catch (error: any) {\n    throw createErrorResponse(`Failed to add document(s) to release ${releaseId}`, error);\n  }\n}\n\n/**\n * Removes one or more documents from a content release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release\n * @param documentIds - ID or array of IDs of the document(s) to remove from the release\n * @returns Result of removing the document(s) from the release\n */\nexport async function removeDocumentFromRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string, \n  documentIds: string | string[]\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  documentIds: string[];\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Normalize document IDs\n    const parsedDocIds = normalizeDocumentIds(documentIds);\n    \n    const processedDocIds = [];\n    const errors: string[] = [];\n    const actions = [];\n    \n    // Process each document ID individually\n    for (const documentId of parsedDocIds) {\n      try {\n        const baseDocId = normalizeBaseDocId(documentId);\n        \n        // Use the version ID format directly: versions.{releaseId}.{documentId}\n        const versionId = `versions.${releaseId}.${baseDocId}`;\n        \n        // Add a document deletion action\n        actions.push({\n          actionType: 'sanity.action.document.delete',\n          documentId: versionId\n        });\n        \n        processedDocIds.push(baseDocId);\n      } catch (documentError: any) {\n        // Log and collect errors for individual documents\n        console.error(`Error processing document ${documentId}:`, documentError);\n        errors.push(`Document ID ${documentId}: ${documentError.message}`);\n      }\n    }\n    \n    // If no documents were processed successfully, throw an error with all collected error messages\n    if (processedDocIds.length === 0) {\n      throw new Error(`Failed to remove any documents from release: ${errors.join('; ')}`);\n    }\n    \n    // Call the Actions API with all document actions\n    const result = await sanityApi.performActions(projectId, dataset, actions);\n    \n    // If we have both successful and failed documents, include that in the message\n    let message = `${processedDocIds.length} document(s) removed from release ${releaseId} successfully`;\n    if (errors.length > 0) {\n      message += `. Warning: ${errors.length} document(s) could not be removed`;\n      console.warn(`Some documents could not be removed from release ${releaseId}:`, errors);\n    }\n    \n    return {\n      success: true,\n      message,\n      releaseId,\n      documentIds: processedDocIds,\n      result\n    };\n  } catch (error: any) {\n    throw createErrorResponse(`Failed to remove document(s) from release ${releaseId}`, error);\n  }\n}\n\n/**\n * Lists all documents in a content release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release\n * @returns List of documents in the release\n */\ninterface ReleaseDocument {\n  versionId: string;\n  documentId: string;\n  type: string;\n  title: string;\n}\n\nexport async function listReleaseDocuments(\n  projectId: string, \n  dataset: string, \n  releaseId: string\n): Promise<{\n  releaseId: string;\n  documentCount: number;\n  documents: ReleaseDocument[];\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Create client with perspective: 'raw' as required for sanity::partOfRelease\n    const client = createSanityClient(projectId, dataset, { perspective: 'raw' });\n    \n    // Use the sanity::partOfRelease function to get all documents in the release\n    const query = `*[sanity::partOfRelease($releaseId)]{ _id, _type, title }`;\n    const params = { releaseId: releaseId };\n    \n    const documents = await client.fetch(query, params);\n    \n    // Map version documents to their base documents\n    const mappedDocuments: ReleaseDocument[] = documents.map((doc: any) => {\n      // Extract the base document ID from the version ID\n      const baseId = doc._id.replace(`versions.${releaseId}.`, '');\n      \n      return {\n        versionId: doc._id,\n        documentId: baseId,\n        type: doc._type,\n        title: doc.title || `Untitled ${doc._type}`,\n      };\n    });\n    \n    return {\n      releaseId,\n      documentCount: mappedDocuments.length,\n      documents: mappedDocuments\n    };\n  } catch (error: any) {\n    console.error(`Error listing documents in release ${releaseId}:`, error);\n    throw new Error(`Failed to list release documents: ${error.message}`);\n  }\n}\n\n/**\n * Publishes all documents in a release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to publish\n * @returns Result of publishing the release\n */\nexport async function publishRelease(\n  projectId: string, \n  dataset: string, \n  releaseId: string\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  documentCount: number;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // First, check how many documents are in the release\n    const documents = await listReleaseDocuments(projectId, dataset, releaseId);\n    \n    // Check if release exceeds document limit (50 docs per release as per docs)\n    if (documents.documentCount > 50) {\n      throw new Error(\n        `Release contains ${documents.documentCount} documents, which exceeds the 50 document limit`\n      );\n    }\n    \n    // Create the publish release action\n    const action = {\n      actionType: 'sanity.action.release.publish',\n      releaseId\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} published successfully`,\n      releaseId,\n      documentCount: documents.documentCount,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error publishing release ${releaseId}:`, error);\n    throw new Error(`Failed to publish release: ${error.message}`);\n  }\n}\n\n/**\n * Lists all releases for a project and dataset\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @returns List of all releases\n */\nexport async function listReleases(\n  projectId: string,\n  dataset: string\n): Promise<{\n  releases: any[];\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    const client = createSanityClient(projectId, dataset);\n    \n    // Query for all releases using the GROQ function\n    const query = `releases::all()`;\n    const releases = await client.fetch(query);\n    \n    return {\n      releases\n    };\n  } catch (error: any) {\n    console.error(`Error listing releases:`, error);\n    \n    // Check for common issues\n    if (error.message?.includes('Unknown GROQ function \"releases::all\"')) {\n      throw new Error(`Failed to list releases: The releases::all() function is not available. Make sure you're using API version 2024-05-23 or later.`);\n    } else if (error.statusCode === 404) {\n      throw new Error(`Failed to list releases: The Content Releases feature might not be enabled for this project or the API token lacks permissions.`);\n    } else if (error.statusCode === 401 || error.statusCode === 403) {\n      throw new Error(`Failed to list releases: Authentication failed. Check that your Sanity token has permission to access releases.`);\n    } else {\n      throw new Error(`Failed to list releases: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Gets a specific release by ID\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to retrieve\n * @returns The release data\n */\nexport async function getRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string\n): Promise<{\n  release: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    const client = createSanityClient(projectId, dataset);\n    \n    // Query for the specific release\n    const query = `*[_id == \"_.releases.${releaseId}\"]`;\n    const releases = await client.fetch(query);\n    \n    if (!releases || releases.length === 0) {\n      throw new Error(`Release with ID ${releaseId} not found`);\n    }\n    \n    return {\n      release: releases[0]\n    };\n  } catch (error: any) {\n    console.error(`Error getting release ${releaseId}:`, error);\n    throw new Error(`Failed to get release: ${error.message}`);\n  }\n}\n\n/**\n * Updates a release's information\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to update\n * @param updateData - Data to update on the release\n * @returns Result of updating the release\n */\nexport async function updateRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string,\n  updateData: {\n    title?: string;\n    description?: string;\n    releaseType?: 'asap' | 'scheduled';\n    intendedPublishAt?: string;\n  }\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Validate required fields for scheduled releases\n    if (updateData.releaseType === 'scheduled' && !updateData.intendedPublishAt) {\n      throw new Error('intendedPublishAt is required for scheduled releases');\n    }\n    \n    // Create the metadata object with only provided fields\n    const metadata: Record<string, any> = {};\n    if (updateData.title) metadata.title = updateData.title;\n    if (updateData.description) metadata.description = updateData.description;\n    if (updateData.releaseType) metadata.releaseType = updateData.releaseType;\n    if (updateData.intendedPublishAt) metadata.intendedPublishAt = updateData.intendedPublishAt;\n    \n    // Create the release edit action\n    const action = {\n      actionType: 'sanity.action.release.edit',\n      releaseId,\n      patch: {\n        id: releaseId, // Add the id property required by SanityAction interface\n        set: {\n          metadata\n        }\n      }\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} updated successfully`,\n      releaseId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error updating release ${releaseId}:`, error);\n    throw new Error(`Failed to update release: ${error.message}`);\n  }\n}\n\n/**\n * Schedules a release for publishing at a specific time\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to schedule\n * @param publishAt - ISO string of when to publish the release\n * @returns Result of scheduling the release\n */\nexport async function scheduleRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string,\n  publishAt: string\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  scheduledTime: string;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Create the schedule release action\n    const action = {\n      actionType: 'sanity.action.release.schedule',\n      releaseId,\n      publishAt\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} scheduled for ${publishAt}`,\n      releaseId,\n      scheduledTime: publishAt,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error scheduling release ${releaseId}:`, error);\n    throw new Error(`Failed to schedule release: ${error.message}`);\n  }\n}\n\n/**\n * Unschedules a previously scheduled release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to unschedule\n * @returns Result of unscheduling the release\n */\nexport async function unscheduleRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Create the unschedule release action\n    const action = {\n      actionType: 'sanity.action.release.unschedule',\n      releaseId\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} unscheduled successfully`,\n      releaseId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error unscheduling release ${releaseId}:`, error);\n    throw new Error(`Failed to unschedule release: ${error.message}`);\n  }\n}\n\n/**\n * Archives a release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to archive\n * @returns Result of archiving the release\n */\nexport async function archiveRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Create the archive release action\n    const action = {\n      actionType: 'sanity.action.release.archive',\n      releaseId\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} archived successfully`,\n      releaseId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error archiving release ${releaseId}:`, error);\n    throw new Error(`Failed to archive release: ${error.message}`);\n  }\n}\n\n/**\n * Unarchives a previously archived release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to unarchive\n * @returns Result of unarchiving the release\n */\nexport async function unarchiveRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Create the unarchive release action\n    const action = {\n      actionType: 'sanity.action.release.unarchive',\n      releaseId\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} unarchived successfully`,\n      releaseId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error unarchiving release ${releaseId}:`, error);\n    throw new Error(`Failed to unarchive release: ${error.message}`);\n  }\n}\n\n/**\n * Deletes an archived release\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name\n * @param releaseId - ID of the release to delete\n * @returns Result of deleting the release\n */\nexport async function deleteRelease(\n  projectId: string,\n  dataset: string,\n  releaseId: string\n): Promise<{\n  success: boolean;\n  message: string;\n  releaseId: string;\n  result: any;\n}> {\n  try {\n    // Check API version first\n    validateApiVersion();\n    \n    // Create the delete release action\n    const action = {\n      actionType: 'sanity.action.release.delete',\n      releaseId\n    };\n    \n    // Call the Actions API\n    const result = await sanityApi.performActions(projectId, dataset, [action]);\n    \n    return {\n      success: true,\n      message: `Release ${releaseId} deleted successfully`,\n      releaseId,\n      result\n    };\n  } catch (error: any) {\n    console.error(`Error deleting release ${releaseId}:`, error);\n    throw new Error(`Failed to delete release: ${error.message}`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/controllers/schema.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[191,194],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[191,194],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[215,218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[215,218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[745,748],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[745,748],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1102,1105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1102,1105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2555,2558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2555,2558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":2,"message":"Function 'checkForReferences' has a complexity of 11. Maximum allowed is 10.","line":100,"column":3,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":131,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3240,3243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3240,3243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3774,3777],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3774,3777],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5317,5320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5317,5320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6171,6174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6171,6174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readFile } from 'fs/promises';\nimport config from '../config/config.js';\nimport { SchemaType } from '../types/index.js';\n\ninterface SchemaTypeDetails extends SchemaType {\n  fields?: any[];\n  [key: string]: any;\n}\n\n/**\n * Gets the full schema for a Sanity project and dataset\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name (default: 'production')\n * @returns The schema object\n */\nexport async function getSchema(projectId: string, dataset: string = 'production'): Promise<SchemaTypeDetails[]> {\n  try {\n    const schemaPath = config.getSchemaPath(projectId, dataset);\n    \n    try {\n      const schemaData = await readFile(schemaPath, 'utf-8');\n      return JSON.parse(schemaData);\n    } catch (readError: any) {\n      if (readError.code === 'ENOENT') {\n        throw new Error(\n          `Schema file not found for project ${projectId} and dataset ${dataset}. ` +\n          `Please run 'npx sanity@latest schema extract' in your Sanity studio and ` +\n          `save the output to ${schemaPath}`\n        );\n      }\n      throw readError;\n    }\n  } catch (error: any) {\n    console.error(`Error getting schema for ${projectId}/${dataset}:`, error);\n    throw new Error(`Failed to get schema: ${error.message}`);\n  }\n}\n\n/**\n * Gets the schema definition for a specific type\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name (default: 'production')\n * @param typeName - The type name\n * @param options - Additional options for retrieving the schema\n * @returns The schema definition for the type\n */\nexport async function getSchemaForType(\n  projectId: string, \n  dataset: string = 'production', \n  typeName: string,\n  options: { includeReferences?: boolean } = {}\n): Promise<SchemaTypeDetails> {\n  try {\n    const schema = await getSchema(projectId, dataset);\n    \n    // Find any type with the given name, not just document types\n    const typeSchema = schema.find(item => item.name === typeName);\n    \n    if (!typeSchema) {\n      throw new Error(`Type ${typeName} not found in schema`);\n    }\n    \n    // If includeReferences is true, also include referenced types\n    if (options.includeReferences) {\n      const result = { \n        ...typeSchema, \n        references: [] as SchemaTypeDetails[]\n      };\n      \n      // Find referenced types\n      const referencedTypes = findReferencedTypes(typeSchema, schema);\n      if (referencedTypes.length > 0) {\n        result.references = referencedTypes;\n      }\n      \n      return result;\n    }\n    \n    return typeSchema;\n  } catch (error: any) {\n    console.error(`Error getting schema for type ${typeName}:`, error);\n    throw new Error(`Failed to get schema for type ${typeName}: ${error.message}`);\n  }\n}\n\n/**\n * Find types that are referenced by a given type\n * \n * @param typeSchema - The type to check for references\n * @param allTypes - All available types in the schema\n * @returns Array of referenced types\n */\nfunction findReferencedTypes(typeSchema: SchemaTypeDetails, allTypes: SchemaTypeDetails[]): SchemaTypeDetails[] {\n  const references: SchemaTypeDetails[] = [];\n  const referencedTypeNames = new Set<string>();\n  \n  // Helper function to recursively check for references\n  function checkForReferences(obj: any) {\n    if (!obj || typeof obj !== 'object') return;\n    \n    // Check if this is a reference definition\n    if (obj.type === 'reference' && obj.to?.type) {\n      referencedTypeNames.add(obj.to.type);\n    }\n    \n    // Check for object types that might be inline or referenced\n    if (obj.type === 'object' && obj.name) {\n      referencedTypeNames.add(obj.name);\n    }\n    \n    // Check arrays for object or reference types\n    if (obj.type === 'array' && obj.of) {\n      (Array.isArray(obj.of) ? obj.of : [obj.of]).forEach((item: any) => {\n        checkForReferences(item);\n      });\n    }\n    \n    // Check for dereferencesTo property which indicates a reference\n    if (obj.dereferencesTo) {\n      referencedTypeNames.add(obj.dereferencesTo);\n    }\n    \n    // Recursively check all other properties\n    Object.values(obj).forEach(value => {\n      if (value && typeof value === 'object') {\n        checkForReferences(value);\n      }\n    });\n  }\n  \n  // Start the recursive search\n  checkForReferences(typeSchema);\n  \n  // Add all found referenced types to the result\n  referencedTypeNames.forEach(name => {\n    const referencedType = allTypes.find(t => t.name === name);\n    if (referencedType && !references.some(r => r.name === name)) {\n      references.push(referencedType);\n    }\n  });\n  \n  return references;\n}\n\n/**\n * Lists available schema types for a Sanity project and dataset\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name (default: 'production')\n * @param options - Options for listing schema types\n * @returns Array of schema type names and their kinds\n */\nexport async function listSchemaTypes(\n  projectId: string, \n  dataset: string = 'production', \n  { allTypes = false }: { allTypes?: boolean } = {}\n): Promise<SchemaType[]> {\n  try {\n    const schema = await getSchema(projectId, dataset);\n    \n    const filteredSchema = allTypes \n      ? schema \n      : schema.filter(item => item.type === 'document');\n    \n    return filteredSchema.map(item => ({\n      name: item.name,\n      type: item.type\n    }));\n  } catch (error: any) {\n    console.error(`Error listing schema types for ${projectId}/${dataset}:`, error);\n    throw new Error(`Failed to list schema types: ${error.message}`);\n  }\n}\n\n/**\n * Gets the detailed schema for a specific type\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name (default: 'production')\n * @param typeName - The name of the type to retrieve\n * @returns The schema definition for the type\n */\nexport async function getTypeSchema(\n  projectId: string, \n  dataset: string = 'production', \n  typeName: string\n): Promise<SchemaTypeDetails> {\n  try {\n    const schema = await getSchema(projectId, dataset);\n    \n    const typeSchema = schema.find(item => item.name === typeName);\n    \n    if (!typeSchema) {\n      throw new Error(`Type '${typeName}' not found in schema`);\n    }\n    \n    return typeSchema;\n  } catch (error: any) {\n    console.error(`Error getting type schema for ${typeName}:`, error);\n    throw new Error(`Failed to get type schema: ${error.message}`);\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used.","line":10,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":14},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":64,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":64,"endColumn":45,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[1519,1563],"text":"// @ts-expect-error - Type issues with the MCP SDK"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { \n  CallToolRequestSchema, \n  ListToolsRequestSchema \n} from '@modelcontextprotocol/sdk/types.js';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\n\nimport config from './config/config.js';\nimport * as toolsRegistry from './tools/index.js';\n\n// Create MCP server\nconst server = new Server(\n  {\n    name: \"Sanity MCP Server\",\n    version: \"0.1.1\"\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\n// Handle tool listing request\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n  const tools = toolsRegistry.getToolDefinitions();\n  \n  return {\n    tools: tools.map(tool => ({\n      name: tool.name,\n      description: tool.description,\n      inputSchema: zodToJsonSchema(tool.parameters),\n    }))\n  };\n});\n\n// Handle tool execution request\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  try {\n    if (!request.params.arguments) {\n      throw new Error(\"Arguments are required\");\n    }\n\n    const result = await toolsRegistry.executeTool(\n      request.params.name, \n      request.params.arguments\n    );\n\n    return {\n      result\n    };\n  } catch (error: unknown) {\n    console.error(\"Error executing tool:\", error);\n    return {\n      error: error instanceof Error ? error.message : String(error)\n    };\n  }\n});\n\n// Start listening on stdio\nconst transport = new StdioServerTransport();\n// @ts-ignore - Type issues with the MCP SDK\nserver.listen(transport);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/actionsTools.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":26,"column":53,"nodeType":"Literal","endLine":26,"endColumn":127},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":27,"column":51,"nodeType":"Literal","endLine":27,"endColumn":124},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1151,1154],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1151,1154],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1809,1812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1809,1812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2547,2550],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2547,2550],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Actions-related tool definitions\n * \n * This file defines all the MCP tool definitions related to document actions\n */\nimport { z } from 'zod';\nimport { ToolDefinition } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport * as actionsController from '../controllers/actions.js';\n\n/**\n * Actions tools provider class\n */\nexport class ActionsToolProvider implements ToolProvider {\n  /**\n   * Get all actions-related tool definitions\n   * \n   * @returns Array of tool definition objects\n   */\n  getToolDefinitions(): ToolDefinition[] {\n    return [\n      {\n        name: 'publishDocument',\n        description: 'Publishes a document from draft to published',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          documentId: z.string().describe('The document ID to publish, must include draft. prefix if publishing a draft')\n        }),\n        handler: async (args: any) => {\n          return await actionsController.publishDocument(args.projectId, args.dataset, args.documentId);\n        }\n      },\n      {\n        name: 'unpublishDocument',\n        description: 'Unpublishes a document, removing the published version',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          documentId: z.string().describe('The document ID to unpublish')\n        }),\n        handler: async (args: any) => {\n          return await actionsController.unpublishDocument(args.projectId, args.dataset, args.documentId);\n        }\n      },\n      {\n        name: 'unpublishDocumentWithRelease',\n        description: 'Unpublishes a document as part of a release',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          releaseId: z.string().describe('The release ID to unpublish with'),\n          documentId: z.string().describe('The document ID to unpublish')\n        }),\n        handler: async (args: any) => {\n          return await actionsController.unpublishDocumentWithRelease(\n            args.projectId, \n            args.dataset, \n            args.releaseId, \n            args.documentId\n          );\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/contextTools.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":33,"column":24,"nodeType":"Literal","endLine":33,"endColumn":59},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2599,2602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2599,2602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3111,3114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3111,3114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3300,3303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3300,3303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Context-related tool definitions\n * \n * This file defines tool definitions related to MCP context and configuration\n */\nimport { z } from 'zod';\nimport { ToolDefinition, InitialContext } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport config from '../config/config.js';\nimport * as embeddingsController from '../controllers/embeddings.js';\nimport * as schemaController from '../controllers/schema.js';\nimport * as releasesController from '../controllers/releases.js';\n\n/**\n * Context tools provider class\n */\nexport class ContextToolProvider implements ToolProvider {\n  /**\n   * Get all context-related tool definitions\n   * \n   * @returns Array of tool definition objects\n   */\n  getToolDefinitions(): ToolDefinition[] {\n    return [\n      {\n        name: 'getInitialContext',\n        description: 'IMPORTANT: Call this tool first to get initial context and usage instructions for this MCP server. This provides critical information about which projects and datasets you should use.',\n        parameters: z.object({}),\n        handler: async (): Promise<InitialContext> => {\n          // Validate that we have project ID and dataset configured\n          if (!config.projectId) {\n            return {\n              message: \"Welcome to the Sanity MCP Server!\",\n              warning: \"SANITY_PROJECT_ID is not configured. Please set it in your environment variables.\",\n              instructions: \"For this prototype, you need to set the following environment variables:\",\n              requiredVariables: [\"SANITY_PROJECT_ID\", \"SANITY_DATASET\", \"SANITY_TOKEN\"],\n              note: \"Once these are set, the server will be ready to use.\"\n            };\n          }\n          \n          try {\n            // Get embeddings indices\n            const embeddingsIndices = await embeddingsController.listEmbeddingsIndices({\n              projectId: config.projectId,\n              dataset: config.dataset || \"production\"\n            });\n            \n            // Get schema types - only document types\n            const documentTypes = await schemaController.listSchemaTypes(\n              config.projectId, \n              config.dataset || \"production\",\n              { allTypes: false }\n            );\n            \n            // Get active releases\n            const releasesResult = await releasesController.listReleases(\n              config.projectId,\n              config.dataset || \"production\"\n            );\n            \n            // Filter to only active releases\n            const activeReleases = releasesResult.releases.filter((release: any) => \n              !release.archivedAt && !release.discardedAt\n            );\n            \n            return {\n              message: \"Welcome to the Sanity MCP Server!\",\n              instructions: \"You can use this server to interact with Sanity content. Start by exploring the schema to understand the content model.\",\n              projectId: config.projectId,\n              dataset: config.dataset || \"production\",\n              embeddingsIndices,\n              documentTypes: documentTypes.map((type: any) => ({\n                name: type.name,\n                title: type.title,\n                type: type.type\n              })),\n              activeReleases: activeReleases.map((release: any) => ({\n                id: release.id,\n                title: release.title,\n                status: release.status\n              })),\n              note: \"The above information provides context about the Sanity project you're working with. You can use the schema types to formulate GROQ queries.\"\n            };\n          } catch (error) {\n            return {\n              message: \"Welcome to the Sanity MCP Server!\",\n              warning: \"Could not fetch complete initial context.\",\n              instructions: \"You can still use the server, but some information may be missing.\",\n              projectId: config.projectId,\n              dataset: config.dataset || \"production\",\n              note: \"Make sure your SANITY_TOKEN has the necessary permissions.\"\n            };\n          }\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/embeddingsTools.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1038,1041],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1038,1041],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2066,2069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2066,2069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Embeddings-related tool definitions\n * \n * This file defines all the MCP tool definitions related to embeddings and semantic search\n */\nimport { z } from 'zod';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport * as embeddingsController from '../controllers/embeddings.js';\n\n/**\n * Provider for embeddings-related tool definitions\n */\nexport class EmbeddingsToolProvider implements ToolProvider {\n  /**\n   * Get all embeddings-related tool definitions\n   * \n   * @returns Array of embeddings tool definitions\n   */\n  getToolDefinitions() {\n    return [\n      {\n        name: 'listEmbeddingsIndices',\n        description: 'List all embeddings indices available for the project and dataset',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment')\n        }),\n        handler: async (args: any) => {\n          return await embeddingsController.listEmbeddingsIndices({\n            projectId: args.projectId,\n            dataset: args.dataset\n          });\n        }\n      },\n      {\n        name: 'semanticSearch',\n        description: 'Perform semantic search on Sanity documents using embeddings',\n        parameters: z.object({\n          query: z.string().describe('The search query to match documents against'),\n          indexName: z.string().describe('The name of the embeddings index to search'),\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          maxResults: z.number().optional().default(10).describe('Maximum number of results to return'),\n          types: z.union([z.string(), z.array(z.string())]).optional().describe('Document type(s) to filter by')\n        }),\n        handler: async (args: any) => {\n          return await embeddingsController.semanticSearch(args.query, {\n            projectId: args.projectId,\n            dataset: args.dataset,\n            indexName: args.indexName,\n            maxResults: args.maxResults,\n            types: args.types\n          });\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/groqTools.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":34,"column":53,"nodeType":"Literal","endLine":34,"endColumn":127},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":35,"column":51,"nodeType":"Literal","endLine":35,"endColumn":124},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1405,1408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1405,1408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2185,2188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2185,2188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2966,2969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2966,2969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * GROQ-related tool definitions\n * \n * This file defines all the MCP tool definitions related to GROQ querying\n */\nimport { z } from 'zod';\nimport { ToolDefinition } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport * as groqController from '../controllers/groq.js';\n\n/**\n * GROQ tools provider class\n */\nexport class GroqToolProvider implements ToolProvider {\n  /**\n   * Get all GROQ-related tool definitions\n   * \n   * @returns Array of tool definition objects\n   */\n  getToolDefinitions(): ToolDefinition[] {\n    return [\n      {\n        name: 'getGroqSpecification',\n        description: 'Get the GROQ language specification',\n        parameters: z.object({}),\n        handler: async () => {\n          return await groqController.getGroqSpecification();\n        }\n      },\n      {\n        name: 'executeGroq',\n        description: 'Run a GROQ query against the dataset',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          query: z.string().describe('GROQ query to run'),\n          params: z.record(z.any()).optional().describe('Optional parameters for the GROQ query')\n        }),\n        handler: async (args: any) => {\n          return await groqController.searchContent(\n            args.projectId,\n            args.dataset,\n            args.query,\n            args.params || {}\n          );\n        }\n      },\n      {\n        name: 'query',\n        description: 'Run a GROQ query against the dataset',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          query: z.string().describe('GROQ query to run'),\n          params: z.record(z.any()).optional().describe('Optional parameters for the GROQ query')\n        }),\n        handler: async (args: any) => {\n          return await groqController.searchContent(\n            args.projectId,\n            args.dataset,\n            args.query,\n            args.params || {}\n          );\n        }\n      },\n      {\n        name: 'getDocument',\n        description: 'Get a document by ID or multiple documents by an array of IDs',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          documentId: z.union([z.string(), z.array(z.string())]).describe('ID or array of IDs of the document(s) to retrieve')\n        }),\n        handler: async (args: any) => {\n          const { projectId, dataset, documentId } = args;\n          \n          if (Array.isArray(documentId)) {\n            return await groqController.searchContent(projectId, dataset, '*[_id in $documentIds]', { documentIds: documentId });\n          }\n          \n          return await groqController.searchContent(projectId, dataset, '*[_id == $documentId][0]', { documentId });\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2321,2324],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2321,2324],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2341,2344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2341,2344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tool definitions registry\n * \n * This file provides a central registry for all MCP tool definitions,\n * aggregating them from specialized tool providers.\n */\nimport { ToolDefinition } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\n\n// Import specialized tool providers\nimport { ContextToolProvider } from './contextTools.js';\nimport { SchemaToolProvider } from './schemaTools.js';\nimport { GroqToolProvider } from './groqTools.js';\nimport { ActionsToolProvider } from './actionsTools.js';\nimport { ReleasesToolProvider } from './releasesTools.js';\nimport { MutateToolProvider } from './mutateTools.js';\nimport { EmbeddingsToolProvider } from './embeddingsTools.js';\nimport { ProjectsToolProvider } from './projectsTools.js';\n\n// Initialize all tool providers\nconst toolProviders: ToolProvider[] = [\n  new ContextToolProvider(),\n  new SchemaToolProvider(),\n  new GroqToolProvider(),\n  new ActionsToolProvider(),\n  new ReleasesToolProvider(),\n  new MutateToolProvider(),\n  new EmbeddingsToolProvider(),\n  new ProjectsToolProvider()\n];\n\n// Cache for tool definitions\nlet toolDefinitionsCache: ToolDefinition[] | null = null;\n\n/**\n * Get all tool definitions\n * \n * @returns Array of tool definition objects\n */\nexport function getToolDefinitions(): ToolDefinition[] {\n  if (toolDefinitionsCache) {\n    return toolDefinitionsCache;\n  }\n  \n  // Collect tool definitions from all providers\n  const toolDefinitions: ToolDefinition[] = [];\n  for (const provider of toolProviders) {\n    toolDefinitions.push(...provider.getToolDefinitions());\n  }\n  \n  // Cache the results\n  toolDefinitionsCache = toolDefinitions;\n  return toolDefinitions;\n}\n\n/**\n * Get a specific tool definition by name\n * \n * @param toolName - The name of the tool to retrieve\n * @returns The tool definition object or null if not found\n */\nexport function getToolDefinition(toolName: string): ToolDefinition | null {\n  const tools = getToolDefinitions();\n  return tools.find(tool => tool.name === toolName) || null;\n}\n\n/**\n * Execute a tool by name with the provided arguments\n * \n * @param toolName - The name of the tool to execute\n * @param args - The arguments to pass to the tool handler\n * @returns The result of the tool execution\n */\nexport async function executeTool(toolName: string, args: Record<string, any> = {}): Promise<any> {\n  const tool = getToolDefinition(toolName);\n  \n  if (!tool) {\n    throw new Error(`Tool '${toolName}' not found`);\n  }\n  \n  if (!tool.handler) {\n    throw new Error(`Tool '${toolName}' has no handler`);\n  }\n  \n  try {\n    // Execute the tool handler with provided arguments\n    return await tool.handler(args);\n  } catch (error) {\n    console.error(`Error executing tool '${toolName}':`, error);\n    throw error;\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/mutateTools.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 6 times.","line":26,"column":53,"nodeType":"Literal","endLine":26,"endColumn":127},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 6 times.","line":27,"column":51,"nodeType":"Literal","endLine":27,"endColumn":124},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 5 times.","line":31,"column":83,"nodeType":"Literal","endLine":31,"endColumn":107},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1393,1396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1393,1396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2284,2287],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2284,2287],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3393,3396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3393,3396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5018,5021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5018,5021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6091,6094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6091,6094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7201,7204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7201,7204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Mutation-related tool definitions\n * \n * This file defines all the MCP tool definitions related to document mutations\n */\nimport { z } from 'zod';\nimport { ToolDefinition } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport * as mutateController from '../controllers/mutate.js';\n\n/**\n * Mutation tools provider class\n */\nexport class MutateToolProvider implements ToolProvider {\n  /**\n   * Get all mutation-related tool definitions\n   * \n   * @returns Array of tool definition objects\n   */\n  getToolDefinitions(): ToolDefinition[] {\n    return [\n      {\n        name: 'createDocument',\n        description: 'Create a new document',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          document: z.record(z.any()).describe('Document content to create'),\n          options: z.object({\n            returnDocuments: z.boolean().optional().describe('Whether to return created documents'),\n            visibility: z.enum(['sync', 'async', 'deferred']).optional().describe('Transaction visibility')\n          }).optional().describe('Options for the create operation')\n        }),\n        handler: async (args: any) => {\n          const mutations = [{ create: args.document }];\n          return await mutateController.modifyDocuments(\n            args.projectId,\n            args.dataset,\n            mutations,\n            args.options?.returnDocuments || false\n          );\n        }\n      },\n      {\n        name: 'mutateDocument',\n        description: 'Apply mutations to documents',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          mutations: z.array(z.record(z.any())).describe('Array of mutation objects'),\n          returnDocuments: z.boolean().optional().describe('Whether to return modified documents')\n        }),\n        handler: async (args: any) => {\n          return await mutateController.modifyDocuments(\n            args.projectId,\n            args.dataset,\n            args.mutations,\n            args.returnDocuments || false\n          );\n        }\n      },\n      {\n        name: 'updateDocument',\n        description: 'Update an existing document',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          documentId: z.string().describe('ID of the document to update'),\n          document: z.record(z.any()).describe('Document content to update with'),\n          options: z.object({\n            returnDocuments: z.boolean().optional().describe('Whether to return updated documents'),\n            visibility: z.enum(['sync', 'async', 'deferred']).optional().describe('Transaction visibility')\n          }).optional().describe('Options for the update operation')\n        }),\n        handler: async (args: any) => {\n          // Make sure _id is included in the document\n          const documentWithId = {\n            _id: args.documentId,\n            ...args.document\n          };\n          \n          const mutations = [{ createOrReplace: documentWithId }];\n          return await mutateController.modifyDocuments(\n            args.projectId,\n            args.dataset, \n            mutations,\n            args.options?.returnDocuments || false\n          );\n        }\n      },\n      {\n        name: 'patchDocument',\n        description: 'Patch an existing document with partial updates',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          documentId: z.string().describe('ID of the document to patch'),\n          patch: z.object({\n            set: z.record(z.any()).optional().describe('Fields to set'),\n            setIfMissing: z.record(z.any()).optional().describe('Fields to set if they are missing'),\n            unset: z.array(z.string()).optional().describe('Fields to unset')\n          }).describe('Patch operations to apply'),\n          options: z.object({\n            returnDocuments: z.boolean().optional().describe('Whether to return patched documents'),\n            visibility: z.enum(['sync', 'async', 'deferred']).optional().describe('Transaction visibility')\n          }).optional().describe('Options for the patch operation')\n        }),\n        handler: async (args: any) => {\n          const mutations = [{\n            patch: {\n              id: args.documentId,\n              ...args.patch\n            }\n          }];\n          \n          return await mutateController.modifyDocuments(\n            args.projectId,\n            args.dataset,\n            mutations,\n            args.options?.returnDocuments || false\n          );\n        }\n      },\n      {\n        name: 'deleteDocument',\n        description: 'Delete a document',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          documentId: z.string().describe('ID of the document to delete'),\n          options: z.object({\n            visibility: z.enum(['sync', 'async', 'deferred']).optional().describe('Transaction visibility')\n          }).optional().describe('Options for the delete operation')\n        }),\n        handler: async (args: any) => {\n          const mutations = [{\n            delete: { id: args.documentId }\n          }];\n          \n          return await mutateController.modifyDocuments(\n            args.projectId,\n            args.dataset,\n            mutations,\n            false\n          );\n        }\n      },\n      {\n        name: 'batchMutations',\n        description: 'Execute a batch of mutations',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          mutations: z.array(z.record(z.any())).describe('Array of mutation objects'),\n          options: z.object({\n            returnDocuments: z.boolean().optional().describe('Whether to return modified documents'),\n            visibility: z.enum(['sync', 'async', 'deferred']).optional().describe('Transaction visibility')\n          }).optional().describe('Options for the batch operation')\n        }),\n        handler: async (args: any) => {\n          return await mutateController.modifyDocuments(\n            args.projectId,\n            args.dataset,\n            args.mutations,\n            args.options?.returnDocuments || false\n          );\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/projectsTools.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[820,823],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[820,823],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1179,1182],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1179,1182],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Projects-related tool definitions\n * \n * This file defines all the MCP tool definitions related to projects and organizations\n */\nimport { z } from 'zod';\nimport { ToolDefinition } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport * as projectsController from '../controllers/projects.js';\n\n/**\n * Projects tools provider class\n */\nexport class ProjectsToolProvider implements ToolProvider {\n  /**\n   * Get all projects-related tool definitions\n   * \n   * @returns Array of tool definition objects\n   */\n  getToolDefinitions(): ToolDefinition[] {\n    return [\n      {\n        name: 'listOrganizationsAndProjects',\n        description: 'List all organizations and their projects that the user has access to',\n        parameters: z.object({}),\n        handler: async (_args: any) => {\n          return await projectsController.listOrganizationsAndProjects();\n        }\n      },\n      {\n        name: 'listStudios',\n        description: 'List all studios for a specific project',\n        parameters: z.object({\n          projectId: z.string().describe('ID of the project to list studios for')\n        }),\n        handler: async (args: any) => {\n          return await projectsController.listStudios(args.projectId);\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/releasesTools.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 5 times.","line":26,"column":53,"nodeType":"Literal","endLine":26,"endColumn":127},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 5 times.","line":27,"column":51,"nodeType":"Literal","endLine":27,"endColumn":124},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1175,1178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1175,1178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1798,1801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1798,1801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2580,2583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2580,2583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3358,3361],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3358,3361],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4090,4093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4090,4093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Releases-related tool definitions\n * \n * This file defines all the MCP tool definitions related to content releases\n */\nimport { z } from 'zod';\nimport { ToolDefinition } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport * as releasesController from '../controllers/releases.js';\n\n/**\n * Releases tools provider class\n */\nexport class ReleasesToolProvider implements ToolProvider {\n  /**\n   * Get all releases-related tool definitions\n   * \n   * @returns Array of tool definition objects\n   */\n  getToolDefinitions(): ToolDefinition[] {\n    return [\n      {\n        name: 'createRelease',\n        description: 'Creates a new content release',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          title: z.string().describe('Title for the release'),\n          description: z.string().optional().describe('Optional description for the release')\n        }),\n        handler: async (args: any) => {\n          return await releasesController.createRelease(\n            args.projectId, \n            args.dataset,\n            args.title,\n            args.description\n          );\n        }\n      },\n      {\n        name: 'listReleases',\n        description: 'Lists all content releases',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment')\n        }),\n        handler: async (args: any) => {\n          return await releasesController.listReleases(args.projectId, args.dataset);\n        }\n      },\n      {\n        name: 'updateRelease',\n        description: 'Updates an existing content release',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          releaseId: z.string().describe('ID of the release to update'),\n          title: z.string().optional().describe('New title for the release'),\n          description: z.string().optional().describe('New description for the release')\n        }),\n        handler: async (args: any) => {\n          return await releasesController.updateRelease(\n            args.projectId,\n            args.dataset,\n            args.releaseId,\n            {\n              title: args.title,\n              description: args.description\n            }\n          );\n        }\n      },\n      {\n        name: 'archiveRelease',\n        description: 'Archives a content release',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          releaseId: z.string().describe('ID of the release to archive')\n        }),\n        handler: async (args: any) => {\n          return await releasesController.archiveRelease(args.projectId, args.dataset, args.releaseId);\n        }\n      },\n      {\n        name: 'addDocumentToRelease',\n        description: 'Adds a document to a release',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          releaseId: z.string().describe('ID of the release to add the document to'),\n          documentId: z.string().describe('ID of the document to add to the release')\n        }),\n        handler: async (args: any) => {\n          return await releasesController.addDocumentToRelease(\n            args.projectId,\n            args.dataset,\n            args.releaseId,\n            args.documentId\n          );\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/tools/schemaTools.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":26,"column":53,"nodeType":"Literal","endLine":26,"endColumn":127},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 3 times.","line":27,"column":51,"nodeType":"Literal","endLine":27,"endColumn":124},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1022,1025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1022,1025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1680,1683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1680,1683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2330,2333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2330,2333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Schema-related tool definitions\n * \n * This file defines all the MCP tool definitions related to schema operations\n */\nimport { z } from 'zod';\nimport { ToolDefinition } from '../types/tools.js';\nimport { ToolProvider } from '../types/toolProvider.js';\nimport * as schemaController from '../controllers/schema.js';\n\n/**\n * Schema tools provider class\n */\nexport class SchemaToolProvider implements ToolProvider {\n  /**\n   * Get all schema-related tool definitions\n   * \n   * @returns Array of tool definition objects\n   */\n  getToolDefinitions(): ToolDefinition[] {\n    return [\n      {\n        name: 'getSchema',\n        description: 'Get the complete schema for a project and dataset',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment')\n        }),\n        handler: async (args: any) => {\n          return await schemaController.getSchema(args.projectId, args.dataset);\n        }\n      },\n      {\n        name: 'listSchemaTypes',\n        description: 'List all schema types for a project and dataset',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          allTypes: z.boolean().optional().describe('Whether to include all types or only document types')\n        }),\n        handler: async (args: any) => {\n          return await schemaController.listSchemaTypes(args.projectId, args.dataset, { allTypes: args.allTypes });\n        }\n      },\n      {\n        name: 'getTypeSchema',\n        description: 'Get the schema for a specific type',\n        parameters: z.object({\n          projectId: z.string().optional().describe('Project ID, if not provided will use the project ID from the environment'),\n          dataset: z.string().optional().describe('Dataset name, if not provided will use the dataset from the environment'),\n          typeName: z.string().describe('The type name to get the schema for')\n        }),\n        handler: async (args: any) => {\n          return await schemaController.getTypeSchema(args.projectId, args.dataset, args.typeName);\n        }\n      }\n    ];\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/types/toolProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/types/tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/utils/documentHelpers.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Function 'applyPatchOperations' has a complexity of 11. Maximum allowed is 10.","line":31,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":50,"endColumn":2},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[932,935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[932,935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[948,951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[948,951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1958,1961],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1958,1961],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2022,2025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2022,2025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2053,2056],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2053,2056],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3054,3057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3054,3057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 15 to the 10 allowed.","line":114,"column":17,"nodeType":null,"messageId":"refactorFunction","endLine":114,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Document helper utility functions for Sanity operations\n */\n\n/**\n * Normalizes document ID to ensure it has a 'drafts.' prefix\n * \n * @param documentId - The document ID to normalize\n * @returns The normalized document ID with 'drafts.' prefix\n */\nexport function normalizeDraftId(documentId: string): string {\n  return documentId.startsWith('drafts.') ? documentId : `drafts.${documentId}`;\n}\n\n/**\n * Normalizes a document ID by removing any 'drafts.' prefix\n * \n * @param documentId - The document ID to normalize\n * @returns The normalized document ID without 'drafts.' prefix\n */\nexport function normalizeBaseDocId(documentId: string): string {\n  return documentId.replace(/^drafts\\./, '');\n}\n\n/**\n * Applies patch operations to a Sanity patch object\n * \n * @param patch - The patch operations to apply\n * @param patchObj - The Sanity patch object to modify\n */\nexport function applyPatchOperations(patch: Record<string, any>, patchObj: any): void {\n  if (patch.set) patchObj.set(patch.set);\n  if (patch.setIfMissing) patchObj.setIfMissing(patch.setIfMissing);\n  if (patch.unset) patchObj.unset(patch.unset);\n  if (patch.inc) patchObj.inc(patch.inc);\n  if (patch.dec) patchObj.dec(patch.dec);\n  \n  // Handle insert operations for arrays\n  if (patch.insert) {\n    const { items, position, at } = patch.insert;\n    if (items && position && at) {\n      patchObj.insert(position, at, items);\n    }\n  }\n  \n  // Handle diffMatchPatch operations for string patching\n  if (patch.diffMatchPatch) {\n    patchObj.diffMatchPatch(patch.diffMatchPatch);\n  }\n}\n\n/**\n * Retrieves document content, trying draft first then published version\n * \n * @param client - Sanity client\n * @param documentId - The document ID to retrieve\n * @param fallbackContent - Optional fallback content\n * @returns The document content or fallback content\n * @throws Error if document not found and no fallback content provided\n */\nexport async function getDocumentContent(\n  client: any, \n  documentId: string, \n  fallbackContent?: Record<string, any>\n): Promise<Record<string, any>> {\n  const baseDocId = normalizeBaseDocId(documentId);\n  const draftId = `drafts.${baseDocId}`;\n  \n  try {\n    // First try to get the draft version\n    let documentContent = await client.getDocument(draftId);\n    \n    // If draft not found, try the published version\n    if (!documentContent) {\n      documentContent = await client.getDocument(baseDocId);\n    }\n    \n    // If content was found, return it\n    if (documentContent) {\n      return documentContent;\n    }\n  } catch (e) {\n    // Intentionally empty, will fall through to check fallback content\n  }\n  \n  // If content parameter is provided, use that instead\n  if (fallbackContent) {\n    return fallbackContent;\n  }\n  \n  throw new Error(`Document ${baseDocId} not found`);\n}\n\n/**\n * Creates a standardized error response for controller functions\n * \n * @param message - The error message\n * @param error - The original error object\n * @returns Standardized error object\n */\nexport function createErrorResponse(message: string, error: any): Error {\n  console.error(`${message}:`, error);\n  return new Error(`${message}: ${error.message}`);\n}\n\n/**\n * Normalizes document IDs from various input formats\n * Handles single IDs, arrays, and JSON string representations\n * \n * @param documentIds - Document IDs in various possible formats\n * @returns Normalized array of document IDs\n * @throws Error if no valid document IDs are provided\n */\nexport function normalizeDocumentIds(documentIds: string | string[]): string[] {\n  let parsedDocIds: string[];\n  \n  if (Array.isArray(documentIds)) {\n    // Already an array - use as is\n    parsedDocIds = documentIds;\n  } else if (typeof documentIds === 'string') {\n    // Check if this is a JSON string array\n    if (documentIds.startsWith('[') && documentIds.endsWith(']')) {\n      try {\n        // Attempt to parse as JSON\n        const parsed = JSON.parse(documentIds);\n        if (Array.isArray(parsed)) {\n          // Successfully parsed as array\n          parsedDocIds = parsed;\n        } else {\n          // Parsed as something else (object, number, etc.) - treat as single ID\n          parsedDocIds = [documentIds];\n        }\n      } catch (e) {\n        // If parsing fails, treat as a single string\n        parsedDocIds = [documentIds];\n      }\n    } else {\n      // Regular string - treat as single ID\n      parsedDocIds = [documentIds];\n    }\n  } else {\n    // Unexpected type - convert to string and use as single ID\n    parsedDocIds = [String(documentIds)];\n  }\n  \n  if (parsedDocIds.length === 0) {\n    throw new Error(\"No document IDs provided\");\n  }\n  \n  return parsedDocIds;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/utils/portableText.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[415,418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[415,418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[509,512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[509,512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[536,539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[536,539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":2,"message":"Arrow function has a complexity of 15. Maximum allowed is 10.","line":41,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":99,"endColumn":4},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 13 to the 10 allowed.","line":41,"column":27,"nodeType":null,"messageId":"refactorFunction","endLine":41,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4288,4291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4288,4291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { marked } from 'marked';\nimport { gfmHeadingId } from 'marked-gfm-heading-id';\n\n// Use the heading ID extension\nmarked.use(gfmHeadingId());\n\ninterface PortableTextSpan {\n  _key?: string;\n  _type?: string;\n  text?: string;\n  marks?: string[];\n}\n\ninterface PortableTextBlock {\n  _key?: string;\n  _type: string;\n  style?: string;\n  listItem?: 'bullet' | 'number';\n  children?: PortableTextSpan[];\n  markDefs?: any[];\n  level?: number;\n  caption?: string;\n  asset?: {\n    _ref: string;\n    [key: string]: any;\n  };\n  [key: string]: any;\n}\n\n/**\n * Converts Portable Text to Markdown\n * \n * @param blocks - Array of Portable Text blocks\n * @returns Markdown string\n */\nexport function portableTextToMarkdown(blocks: PortableTextBlock[]): string {\n  if (!blocks || !Array.isArray(blocks)) {\n    return '';\n  }\n  \n  return blocks.map(block => {\n    // Handle different block types\n    if (block._type === 'block') {\n      // Convert text spans with marks to markdown\n      const text = block.children\n        ?.map(span => {\n          let result = span.text || '';\n          \n          // Apply marks (bold, italic, etc)\n          if (span.marks && span.marks.length > 0) {\n            span.marks.forEach(mark => {\n              // Handle different mark types\n              if (mark === 'strong') {\n                result = `**${result}**`;\n              } else if (mark === 'em') {\n                result = `*${result}*`;\n              } else if (mark === 'code') {\n                result = `\\`${result}\\``;\n              }\n              // Additional marks could be handled here\n            });\n          }\n          \n          return result;\n        })\n        .join('') || '';\n      \n      // Handle block styles (headings, lists, etc)\n      if (block.style === 'h1') {\n        return `# ${text}`;\n      } else if (block.style === 'h2') {\n        return `## ${text}`;\n      } else if (block.style === 'h3') {\n        return `### ${text}`;\n      } else if (block.style === 'h4') {\n        return `#### ${text}`;\n      } else if (block.style === 'h5') {\n        return `##### ${text}`;\n      } else if (block.style === 'h6') {\n        return `###### ${text}`;\n      } else if (block.style === 'blockquote') {\n        return `> ${text}`;\n      } else if (block.listItem === 'bullet') {\n        return `- ${text}`;\n      } else if (block.listItem === 'number') {\n        return `1. ${text}`;\n      }\n      \n      // Default to normal paragraph\n      return text;\n    } else if (block._type === 'image' && block.asset) {\n      // Handle image blocks\n      const caption = block.caption || '';\n      return `![${caption}](${block.asset._ref})`;\n    }\n    \n    // Handle other block types or return empty string\n    return '';\n  }).join('\\n\\n');\n}\n\n/**\n * Converts Markdown to Portable Text\n * \n * @param markdown - Markdown string to convert\n * @returns Array of Portable Text blocks\n */\nexport function markdownToPortableText(markdown: string): PortableTextBlock[] {\n  if (!markdown) {\n    return [];\n  }\n  \n  // Parse markdown to tokens\n  const tokens = marked.lexer(markdown);\n  const blocks: PortableTextBlock[] = [];\n  \n  tokens.forEach(token => {\n    // Handle different token types\n    if (token.type === 'paragraph') {\n      blocks.push({\n        _key: generateKey(),\n        _type: 'block',\n        style: 'normal',\n        children: [\n          {\n            _key: generateKey(),\n            _type: 'span',\n            text: token.text,\n            marks: []\n          }\n        ],\n        markDefs: []\n      });\n    } else if (token.type === 'heading') {\n      blocks.push({\n        _key: generateKey(),\n        _type: 'block',\n        style: `h${token.depth}`,\n        children: [\n          {\n            _key: generateKey(),\n            _type: 'span',\n            text: token.text,\n            marks: []\n          }\n        ],\n        markDefs: []\n      });\n    } else if (token.type === 'blockquote') {\n      blocks.push({\n        _key: generateKey(),\n        _type: 'block',\n        style: 'blockquote',\n        children: [\n          {\n            _key: generateKey(),\n            _type: 'span',\n            text: token.text,\n            marks: []\n          }\n        ],\n        markDefs: []\n      });\n    } else if (token.type === 'list') {\n      token.items.forEach((item: any) => {\n        blocks.push({\n          _key: generateKey(),\n          _type: 'block',\n          style: 'normal',\n          listItem: token.ordered ? 'number' : 'bullet',\n          level: 1,\n          children: [\n            {\n              _key: generateKey(),\n              _type: 'span',\n              text: item.text,\n              marks: []\n            }\n          ],\n          markDefs: []\n        });\n      });\n    } else if (token.type === 'code') {\n      blocks.push({\n        _key: generateKey(),\n        _type: 'block',\n        style: 'normal',\n        children: [\n          {\n            _key: generateKey(),\n            _type: 'span',\n            text: token.text,\n            marks: ['code']\n          }\n        ],\n        markDefs: []\n      });\n    } else if (token.type === 'image') {\n      blocks.push({\n        _key: generateKey(),\n        _type: 'image',\n        caption: token.text,\n        asset: {\n          _ref: token.href\n        }\n      });\n    }\n    // Additional token types can be handled here\n  });\n  \n  return blocks;\n}\n\n/**\n * Generate a random key for Portable Text objects\n */\nfunction generateKey(): string {\n  return Math.random().toString(36).substring(2, 15);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/src/utils/sanityClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[540,543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[540,543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1052,1055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1052,1055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1093,1096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1093,1096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1136,1139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1136,1139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1195,1198],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1195,1198],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1235,1238],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1235,1238],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1291,1294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1291,1294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1322,1325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1322,1325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1353,1356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1353,1356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1542,1545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1542,1545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1578,1581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1578,1581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1708,1711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1708,1711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient, SanityClient } from '@sanity/client';\nimport fetch from 'node-fetch';\nimport config from '../config/config.js';\n\n/**\n * Creates a Sanity client for a specific project and dataset\n * \n * @param projectId - Sanity project ID\n * @param dataset - Dataset name (default: 'production')\n * @param options - Additional options to pass to the Sanity client\n * @returns Configured Sanity client instance\n */\nexport function createSanityClient(\n  projectId: string, \n  dataset: string = 'production', \n  options: Record<string, any> = {}\n): SanityClient {\n  return createClient({\n    projectId,\n    dataset,\n    apiVersion: config.apiVersion,\n    token: config.sanityToken,\n    useCdn: false, // Using the API directly ensures we get fresh content\n    ...options\n  });\n}\n\ninterface SanityProject {\n  id: string;\n  displayName: string;\n  organizationId: string;\n  isDefault: boolean;\n  createdAt: string;\n  studioHost?: string;\n  members: Array<{\n    id: string;\n    role: string;\n  }>;\n}\n\ninterface SanityAction {\n  create?: Record<string, any>;\n  createOrReplace?: Record<string, any>;\n  createIfNotExists?: Record<string, any>;\n  patch?: {\n    id: string;\n    set?: Record<string, any>;\n    setIfMissing?: Record<string, any>;\n    unset?: string[];\n    insert?: Record<string, any>;\n    inc?: Record<string, any>;\n    dec?: Record<string, any>;\n  };\n  delete?: {\n    id: string;\n  };\n  // Custom Sanity actions\n  actionType?: string;\n  draftId?: string;\n  publishedId?: string;\n  releaseId?: string;\n  metadata?: Record<string, any>;\n  attributes?: Record<string, any>;\n}\n\ninterface SanityActionResult {\n  transactionId: string;\n  results: Array<{\n    id: string;\n    document?: Record<string, any>;\n  }>;\n}\n\n/**\n * Checks if the provided API version is sufficient for the required minimum version\n * \n * @param currentVersion - Current API version (e.g., '2024-05-23')\n * @param requiredVersion - Minimum required API version\n * @returns True if current version is equal to or newer than required\n */\nexport function isSufficientApiVersion(currentVersion: string, requiredVersion: string): boolean {\n  // Convert versions to comparable format (YYYY-MM-DD → YYYYMMDD)\n  const formatVersion = (version: string): number => {\n    // Remove 'v' prefix if present\n    const cleanVersion = version.replace(/^v/, '');\n    \n    // Handle versions without dashes (already in YYYYMMDD format)\n    if (!cleanVersion.includes('-')) {\n      // Make sure it's a valid 8-digit number\n      const numVersion = parseInt(cleanVersion, 10);\n      if (!isNaN(numVersion) && cleanVersion.length === 8) {\n        return numVersion;\n      }\n    }\n    \n    // Convert from YYYY-MM-DD format\n    const parts = cleanVersion.split('-');\n    if (parts.length !== 3) {\n      throw new Error(`Invalid version format: ${version}. Expected YYYY-MM-DD`);\n    }\n    \n    return parseInt(parts.join(''), 10);\n  };\n  \n  try {\n    const current = formatVersion(currentVersion);\n    const required = formatVersion(requiredVersion);\n    \n    return current >= required;\n  } catch (error) {\n    console.error(`Error comparing API versions: ${error}`);\n    // If there's any error in parsing, assume version is insufficient\n    return false;\n  }\n}\n\n/**\n * Makes direct HTTP requests to Sanity APIs not covered by the client\n */\nexport const sanityApi = {\n  /**\n   * Fetches all projects accessible to the user\n   * \n   * @returns Promise with list of projects\n   */\n  async listProjects(): Promise<SanityProject[]> {\n    const response = await fetch('https://api.sanity.io/v2021-06-07/projects', {\n      headers: {\n        'Authorization': `Bearer ${config.sanityToken}`\n      }\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to fetch projects: ${response.statusText}`);\n    }\n    \n    return response.json() as Promise<SanityProject[]>;\n  },\n  \n  /**\n   * Call the Sanity Actions API\n   * \n   * @param projectId - Sanity project ID\n   * @param dataset - Dataset name\n   * @param actions - Array of action objects\n   * @returns Promise with action result\n   */\n  async performActions(projectId: string, dataset: string, actions: SanityAction[]): Promise<SanityActionResult> {\n    // IMPORTANT: The Actions API requires at least API version 2024-05-23\n    // The correct endpoint is: https://{projectId}.api.sanity.io/v{apiVersion}/data/actions/{dataset}\n    // Note: \"actions\" (plural) not \"action\" (singular)\n    const url = `https://${projectId}.api.sanity.io/v${config.apiVersion}/data/actions/${dataset}`;\n    \n    console.log(`Calling actions API: ${url}`);\n    \n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${config.sanityToken}`\n      },\n      body: JSON.stringify({ actions })\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`Action API error response:`, {\n        status: response.status,\n        statusText: response.statusText,\n        errorText,\n        url\n      });\n      throw new Error(`Action API error: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n    \n    return response.json() as Promise<SanityActionResult>;\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/controllers/actions.test.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 7 times.","line":36,"column":37,"nodeType":"Literal","endLine":36,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { createSanityClient, sanityApi } from '../../src/utils/sanityClient.js';\nimport { \n  publishDocument, \n  unpublishDocument\n} from '../../src/controllers/actions.js';\n\n// Mock the sanityClient and its API\nvi.mock('../../src/utils/sanityClient.js', () => ({\n  createSanityClient: vi.fn(),\n  sanityApi: {\n    performActions: vi.fn()\n  }\n}));\n\ndescribe('Actions Controller', () => {\n  // Mock client and its methods\n  const mockClient = {\n    getDocument: vi.fn(),\n    fetch: vi.fn()\n  };\n  \n  // Mock API responses\n  const mockPerformActionsResponse = {\n    transactionId: 'trans123',\n    results: [{ id: 'result1', success: true }]\n  };\n  \n  beforeEach(() => {\n    // Setup mocks\n    (createSanityClient as any).mockReturnValue(mockClient);\n    (sanityApi.performActions as any).mockResolvedValue(mockPerformActionsResponse);\n    \n    // Reset document fetch behavior\n    mockClient.getDocument.mockImplementation((id: string) => {\n      if (id === 'doc123' || id === 'drafts.doc123') {\n        return Promise.resolve({\n          _id: id,\n          _type: 'article',\n          title: 'Test Document'\n        });\n      }\n      return Promise.reject(new Error('Document not found'));\n    });\n    \n    // Clear mock call history\n    vi.clearAllMocks();\n  });\n  \n  afterEach(() => {\n    vi.resetAllMocks();\n  });\n  \n  describe('publishDocument', () => {\n    it('should publish a draft document', async () => {\n      const result = await publishDocument('project123', 'dataset123', 'drafts.doc123');\n      \n      expect(sanityApi.performActions).toHaveBeenCalledWith('project123', 'dataset123', [\n        expect.objectContaining({\n          actionType: 'sanity.action.document.publish',\n          draftId: 'drafts.doc123',\n          publishedId: 'doc123'\n        })\n      ]);\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true,\n        documentId: 'doc123'\n      }));\n    });\n    \n    it('should handle document IDs without drafts prefix', async () => {\n      const result = await publishDocument('project123', 'dataset123', 'doc123');\n      \n      expect(sanityApi.performActions).toHaveBeenCalledWith('project123', 'dataset123', [\n        expect.objectContaining({\n          actionType: 'sanity.action.document.publish',\n          draftId: 'drafts.doc123',\n          publishedId: 'doc123'\n        })\n      ]);\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true,\n        documentId: 'doc123'\n      }));\n    });\n    \n    it('should throw an error when publishing fails', async () => {\n      (sanityApi.performActions as any).mockRejectedValueOnce(new Error('Failed to publish'));\n      \n      await expect(publishDocument('project123', 'dataset123', 'doc123')).rejects.toThrow('Failed to publish document');\n    });\n  });\n  \n  describe('unpublishDocument', () => {\n    it('should unpublish a document', async () => {\n      const result = await unpublishDocument('project123', 'dataset123', 'doc123');\n      \n      expect(sanityApi.performActions).toHaveBeenCalledWith('project123', 'dataset123', [\n        expect.objectContaining({\n          actionType: 'sanity.action.document.unpublish',\n          documentId: 'doc123'\n        })\n      ]);\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true,\n        draftId: 'drafts.doc123'\n      }));\n    });\n    \n    it('should handle document IDs with drafts prefix', async () => {\n      const result = await unpublishDocument('project123', 'dataset123', 'drafts.doc123');\n      \n      expect(sanityApi.performActions).toHaveBeenCalledWith('project123', 'dataset123', [\n        expect.objectContaining({\n          actionType: 'sanity.action.document.unpublish',\n          documentId: 'doc123'\n        })\n      ]);\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true,\n        draftId: 'drafts.doc123'\n      }));\n    });\n    \n    it('should throw an error when unpublishing fails', async () => {\n      (sanityApi.performActions as any).mockRejectedValueOnce(new Error('Failed to unpublish'));\n      \n      await expect(unpublishDocument('project123', 'dataset123', 'doc123')).rejects.toThrow('Failed to unpublish document');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/controllers/embeddings.test.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 7 times.","line":16,"column":16,"nodeType":"Literal","endLine":16,"endColumn":30},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 7 times.","line":17,"column":14,"nodeType":"Literal","endLine":17,"endColumn":28},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 5 times.","line":34,"column":17,"nodeType":"Literal","endLine":34,"endColumn":29},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":38,"column":22,"nodeType":"Literal","endLine":38,"endColumn":44},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 5 times.","line":140,"column":43,"nodeType":"Literal","endLine":140,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { listEmbeddingsIndices, semanticSearch } from '../../src/controllers/embeddings.js';\nimport config from '../../src/config/config.js';\n\n// Mock fetch\nglobal.fetch = vi.fn();\n\n// Mock the client\nvi.mock('@sanity/client', () => ({\n  createClient: vi.fn()\n}));\n\n// Mock config\nvi.mock('../../src/config/config.js', () => ({\n  default: {\n    projectId: 'test-project',\n    dataset: 'test-dataset',\n    apiVersion: '2023-01-01',\n    sanityToken: 'test-token',\n    openAiApiKey: 'test-openai-key'\n  }\n}));\n\ndescribe('Embeddings Controller', () => {\n  beforeEach(() => {\n    // Reset all mocks\n    vi.resetAllMocks();\n    \n    // Setup fetch mock for embeddings API\n    (global.fetch as any).mockResolvedValue({\n      ok: true,\n      json: vi.fn().mockResolvedValue([\n        {\n          name: 'test-index',\n          status: 'ready',\n          documentCount: 100,\n          dimensions: 1536,\n          createdAt: '2023-01-01T00:00:00Z',\n          updatedAt: '2023-01-01T00:00:00Z'\n        }\n      ])\n    });\n  });\n  \n  describe('listEmbeddingsIndices', () => {\n    it('should list embeddings indices for a dataset', async () => {\n      const mockResponseJson = [\n        {\n          name: 'test-index',\n          status: 'ready',\n          documentCount: 100,\n          dimensions: 1536,\n          createdAt: '2023-01-01T00:00:00Z',\n          updatedAt: '2023-01-01T00:00:00Z'\n        }\n      ];\n      \n      (global.fetch as any).mockResolvedValueOnce({\n        ok: true,\n        json: vi.fn().mockResolvedValue(mockResponseJson)\n      });\n\n      const indices = await listEmbeddingsIndices({\n        projectId: 'test-project',\n        dataset: 'test-dataset'\n      });\n      \n      expect(indices).toBeDefined();\n      expect(Array.isArray(indices)).toBe(true);\n      expect(indices).toHaveLength(1);\n      expect(indices[0].name).toBe('test-index');\n      expect(global.fetch).toHaveBeenCalledWith(\n        'https://test-project.api.sanity.io/vX/embeddings-index/test-dataset',\n        expect.objectContaining({\n          method: 'GET',\n          headers: expect.objectContaining({\n            Authorization: 'Bearer test-token'\n          })\n        })\n      );\n    });\n    \n    it('should throw error with missing projectId and dataset', async () => {\n      await expect(listEmbeddingsIndices({\n        projectId: '',\n        dataset: ''\n      })).rejects.toThrow('Project ID and Dataset name are required');\n    });\n    \n    it('should throw error with no sanity token', async () => {\n      // Temporarily remove token\n      const originalConfig = { ...config };\n      Object.assign(config, { sanityToken: '' });\n      \n      await expect(listEmbeddingsIndices({\n        projectId: 'test-project',\n        dataset: 'test-dataset'\n      })).rejects.toThrow('SANITY_TOKEN is missing');\n      \n      // Restore token\n      Object.assign(config, originalConfig);\n    });\n    \n    it('should handle API errors', async () => {\n      (global.fetch as any).mockResolvedValueOnce({\n        ok: false,\n        status: 401,\n        statusText: 'Unauthorized',\n        text: vi.fn().mockResolvedValue('Unauthorized')\n      });\n      \n      await expect(listEmbeddingsIndices({\n        projectId: 'test-project',\n        dataset: 'test-dataset'\n      })).rejects.toThrow('Authentication failed');\n    });\n  });\n  \n  describe('semanticSearch', () => {\n    beforeEach(() => {\n      // Setup fetch mock for semanticSearch API\n      (global.fetch as any).mockResolvedValue({\n        ok: true,\n        json: vi.fn().mockResolvedValue([\n          {\n            _id: 'doc1',\n            title: 'Test Document 1',\n            _score: 0.95\n          },\n          {\n            _id: 'doc2',\n            title: 'Test Document 2',\n            _score: 0.85\n          }\n        ])\n      });\n    });\n    \n    it('should search content using query', async () => {\n      const result = await semanticSearch('test query', {\n        indexName: 'test-index',\n        maxResults: 10,\n        types: ['article'],\n        projectId: 'test-project',\n        dataset: 'test-dataset'\n      });\n      \n      expect(result.hits).toHaveLength(2);\n      expect(result.total).toBe(2);\n      expect(result.hits[0]._id).toBe('doc1');\n      expect(global.fetch).toHaveBeenCalledWith(\n        'https://test-project.api.sanity.io/vX/embeddings-index/query/test-dataset/test-index',\n        expect.objectContaining({\n          method: 'POST',\n          body: expect.stringContaining('test query')\n        })\n      );\n    });\n    \n    it('should handle errors when searching content', async () => {\n      (global.fetch as any).mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n        statusText: 'Not Found',\n        text: vi.fn().mockResolvedValue('Not Found')\n      });\n      \n      await expect(semanticSearch('test query', {\n        indexName: 'nonexistent-index',\n        projectId: 'test-project',\n        dataset: 'test-dataset'\n      })).rejects.toThrow('Embeddings index \"nonexistent-index\" not found');\n    });\n    \n    it('should require project ID and dataset', async () => {\n      await expect(semanticSearch('test query', {\n        projectId: '',\n        dataset: '',\n        indexName: 'test-index'\n      })).rejects.toThrow('Project ID and Dataset name are required');\n    });\n    \n    it('should require an index name', async () => {\n      await expect(semanticSearch('test query', {\n        indexName: '',\n        projectId: 'test-project',\n        dataset: 'test-dataset'\n      })).rejects.toThrow('indexName parameter is required for semantic search');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/controllers/groq.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/controllers/mutate.test.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 12 times.","line":74,"column":16,"nodeType":"Literal","endLine":74,"endColumn":28},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":250,"column":15,"nodeType":"Literal","endLine":250,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { createSanityClient } from '../../src/utils/sanityClient.js';\nimport { modifyDocuments, Mutation } from '../../src/controllers/mutate.js';\n\n// Mock the sanityClient and portableText utils\nvi.mock('../../src/utils/sanityClient.js');\n\ndescribe('Mutate Controller', () => {\n  // Mock client and its methods\n  const mockClient = {\n    transaction: vi.fn(),\n    patch: vi.fn(),\n    getDocument: vi.fn(),\n  };\n  \n  // Mock transaction object\n  const mockTransaction = {\n    create: vi.fn().mockReturnThis(),\n    createOrReplace: vi.fn().mockReturnThis(),\n    createIfNotExists: vi.fn().mockReturnThis(),\n    delete: vi.fn().mockReturnThis(),\n    patch: vi.fn().mockReturnThis(),\n    commit: vi.fn().mockResolvedValue({ documentIds: ['doc1', 'doc2'] }),\n  };\n  \n  // Mock patch object\n  const mockPatch = {\n    set: vi.fn().mockReturnThis(),\n    setIfMissing: vi.fn().mockReturnThis(),\n    unset: vi.fn().mockReturnThis(),\n    inc: vi.fn().mockReturnThis(),\n    dec: vi.fn().mockReturnThis(),\n    insert: vi.fn().mockReturnThis(),\n    ifRevisionId: vi.fn().mockReturnThis(),\n    commit: vi.fn().mockResolvedValue({ transactionId: 'transaction123' }),\n  };\n  \n  beforeEach(() => {\n    // Set up mocks\n    (createSanityClient as any).mockReturnValue(mockClient);\n    mockClient.transaction.mockReturnValue(mockTransaction);\n    mockClient.patch.mockReturnValue(mockPatch);\n    \n    // Mock document retrieval\n    mockClient.getDocument.mockImplementation((id: string) => {\n      if (id === 'article123') {\n        return Promise.resolve({\n          _id: 'article123',\n          title: 'Test Article',\n          body: [\n            { _type: 'block', children: [{ _type: 'span', text: 'Existing text' }] }\n          ]\n        });\n      }\n      return Promise.reject(new Error(`Document ${id} not found`));\n    });\n    \n    // Clear mock call history\n    vi.clearAllMocks();\n  });\n  \n  afterEach(() => {\n    vi.resetAllMocks();\n  });\n  \n  describe('modifyDocuments', () => {\n    it('should throw an error if no mutations are provided', async () => {\n      await expect(modifyDocuments('project123', 'dataset123', [])).rejects.toThrow('At least one mutation is required');\n    });\n    \n    it('should create a document', async () => {\n      const mutations: Mutation[] = [{\n        create: {\n          _id: 'person-123',\n          _type: 'person',\n          name: 'John Doe',\n          age: 30\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(createSanityClient).toHaveBeenCalledWith('project123', 'dataset123');\n      expect(mockClient.transaction).toHaveBeenCalled();\n      expect(mockTransaction.create).toHaveBeenCalledWith(mutations[0].create);\n      expect(mockTransaction.commit).toHaveBeenCalled();\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true,\n        message: 'Successfully applied 1 mutations'\n      }));\n    });\n    \n    it('should createOrReplace a document', async () => {\n      const mutations: Mutation[] = [{\n        createOrReplace: {\n          _id: 'person-123',\n          _type: 'person',\n          name: 'John Doe',\n          age: 30\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockTransaction.createOrReplace).toHaveBeenCalledWith(mutations[0].createOrReplace);\n      expect(mockTransaction.commit).toHaveBeenCalled();\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should createIfNotExists a document', async () => {\n      const mutations: Mutation[] = [{\n        createIfNotExists: {\n          _id: 'person-123',\n          _type: 'person',\n          name: 'John Doe',\n          age: 30\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockTransaction.createIfNotExists).toHaveBeenCalledWith(mutations[0].createIfNotExists);\n      expect(mockTransaction.commit).toHaveBeenCalled();\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should delete a document by id', async () => {\n      const mutations: Mutation[] = [{\n        delete: {\n          id: 'person-123'\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockTransaction.delete).toHaveBeenCalled();\n      expect(mockTransaction.commit).toHaveBeenCalled();\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should delete documents by query', async () => {\n      const mutations: Mutation[] = [{\n        delete: {\n          query: '*[_type == \"person\" && age < $age]',\n          params: { age: 18 }\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockTransaction.delete).toHaveBeenCalled();\n      expect(mockTransaction.commit).toHaveBeenCalled();\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should patch a document by id', async () => {\n      const mutations: Mutation[] = [{\n        patch: {\n          id: 'person-123',\n          set: {\n            name: 'Jane Doe',\n            'profile.bio': 'Updated bio'\n          },\n          inc: {\n            age: 1\n          },\n          unset: ['oldField', 'deprecatedField']\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockClient.patch).toHaveBeenCalledWith('person-123');\n      expect(mockPatch.set).toHaveBeenCalledWith({\n        name: 'Jane Doe',\n        'profile.bio': 'Updated bio'\n      });\n      expect(mockPatch.inc).toHaveBeenCalledWith({ age: 1 });\n      expect(mockPatch.unset).toHaveBeenCalledWith(['oldField', 'deprecatedField']);\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should patch documents by query', async () => {\n      const mutations: Mutation[] = [{\n        patch: {\n          query: '*[_type == \"person\" && age >= $age]',\n          params: { age: 18 },\n          set: {\n            isAdult: true\n          }\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockTransaction.patch).toHaveBeenCalledWith({\n        query: '*[_type == \"person\" && age >= $age]',\n        params: { age: 18 },\n        set: {\n          isAdult: true\n        }\n      });\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should support optimistic locking with ifRevisionID', async () => {\n      const mutations: Mutation[] = [{\n        patch: {\n          id: 'person-123',\n          ifRevisionID: 'rev-abc-123',\n          set: {\n            name: 'Jane Doe'\n          }\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockClient.patch).toHaveBeenCalledWith('person-123');\n      expect(mockPatch.ifRevisionId).toHaveBeenCalledWith('rev-abc-123');\n      expect(mockPatch.set).toHaveBeenCalledWith({ name: 'Jane Doe' });\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should handle array insertions with various positions', async () => {\n      const mutations: Mutation[] = [{\n        patch: {\n          id: 'article-123',\n          insert: {\n            items: [{ _type: 'comment', text: 'Great article!' }],\n            position: 'after',\n            at: 'comments[-1]'\n          }\n        }\n      }];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockClient.patch).toHaveBeenCalledWith('article-123');\n      expect(mockPatch.insert).toHaveBeenCalledWith(\n        'after', \n        'comments[-1]', \n        [{ _type: 'comment', text: 'Great article!' }]\n      );\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true\n      }));\n    });\n    \n    it('should handle multiple mutations in a single transaction', async () => {\n      const mutations: Mutation[] = [\n        {\n          create: {\n            _id: 'person-123',\n            _type: 'person',\n            name: 'John Doe'\n          }\n        },\n        {\n          patch: {\n            id: 'article-123',\n            set: {\n              author: 'person-123'\n            }\n          }\n        }\n      ];\n      \n      const result = await modifyDocuments('project123', 'dataset123', mutations);\n      \n      expect(mockTransaction.create).toHaveBeenCalledWith(mutations[0].create);\n      expect(mockClient.patch).toHaveBeenCalledWith('article-123');\n      expect(mockPatch.set).toHaveBeenCalledWith({ author: 'person-123' });\n      \n      expect(result).toEqual(expect.objectContaining({\n        success: true,\n        message: 'Successfully applied 2 mutations'\n      }));\n    });\n    \n    it('should throw an error when the transaction fails', async () => {\n      mockTransaction.commit.mockRejectedValueOnce(new Error('Transaction failed'));\n      \n      const mutations: Mutation[] = [{\n        create: {\n          _id: 'person-123',\n          _type: 'person',\n          name: 'John Doe'\n        }\n      }];\n      \n      await expect(modifyDocuments('project123', 'dataset123', mutations))\n        .rejects.toThrow('Failed to modify documents: Transaction failed');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/controllers/releases.test.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":63,"column":25,"nodeType":"Literal","endLine":63,"endColumn":39},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":426,"column":25,"nodeType":"Literal","endLine":426,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect, describe, it, vi, beforeEach, afterEach } from 'vitest';\nimport * as releasesController from '../../src/controllers/releases.js';\nimport { sanityApi, createSanityClient } from '../../src/utils/sanityClient.js';\nimport config from '../../src/config/config.js';\n\n// Mock the sanityClient module\nvi.mock('../../src/utils/sanityClient.js', () => {\n  return {\n    sanityApi: {\n      performActions: vi.fn()\n    },\n    createSanityClient: vi.fn((_projectId, _dataset, _options = {}) => ({\n      fetch: vi.fn(),\n      getDocument: vi.fn(),\n      query: vi.fn()\n    })),\n    isSufficientApiVersion: vi.fn().mockReturnValue(true)\n  };\n});\n\n// Mock the config module to return a valid API version\nvi.mock('../../src/config/config.js', () => {\n  return {\n    default: {\n      apiVersion: '2025-02-19',\n      token: 'mock-token',\n      projectId: 'mock-project',\n      dataset: 'production'\n    }\n  }\n});\n\ndescribe('Releases Controller', () => {\n  const mockProjectId = 'test-project';\n  const mockDataset = 'test-dataset';\n  const mockReleaseId = 'test-release-123';\n  const mockDocumentId = 'test-doc-123';\n  const mockClient = { fetch: vi.fn(), getDocument: vi.fn(), query: vi.fn() };\n  \n  beforeEach(() => {\n    vi.resetAllMocks();\n    (createSanityClient as any).mockReturnValue(mockClient);\n    \n    // Setup mock document behavior\n    mockClient.getDocument.mockImplementation((id: string) => {\n      if (id === mockDocumentId || id === `drafts.${mockDocumentId}`) {\n        return Promise.resolve({\n          _id: id,\n          _type: 'article',\n          title: 'Test Document'\n        });\n      }\n      return Promise.reject(new Error(`Document ${id} not found`));\n    });\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('createRelease', () => {\n    it('should create a release with title', async () => {\n      const mockTitle = 'Test Release';\n      const mockResult = { transactionId: 'tx123' };\n      \n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.createRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId,\n        mockTitle\n      );\n\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.release.create',\n            releaseId: mockReleaseId,\n            metadata: {\n              title: mockTitle\n            }\n          }\n        ]\n      );\n\n      expect(result).toEqual({\n        success: true,\n        message: `Release ${mockReleaseId} created successfully`,\n        releaseId: mockReleaseId,\n        result: mockResult\n      });\n    });\n\n    it('should create a release with title and options', async () => {\n      const mockTitle = 'Test Release';\n      const mockOptions = {\n        description: 'Test description',\n        releaseType: 'scheduled' as const,\n        intendedPublishAt: '2025-04-01T12:00:00Z'\n      };\n      const mockResult = { transactionId: 'tx123' };\n      \n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.createRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId,\n        mockTitle,\n        mockOptions\n      );\n\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.release.create',\n            releaseId: mockReleaseId,\n            metadata: {\n              title: mockTitle,\n              description: mockOptions.description,\n              releaseType: mockOptions.releaseType,\n              intendedPublishAt: mockOptions.intendedPublishAt\n            }\n          }\n        ]\n      );\n\n      expect(result).toEqual({\n        success: true,\n        message: `Release ${mockReleaseId} created successfully`,\n        releaseId: mockReleaseId,\n        result: mockResult\n      });\n    });\n\n    it('should handle errors when creating a release', async () => {\n      const mockTitle = 'Test Release';\n      const mockError = new Error('Test error');\n      \n      (sanityApi.performActions as any).mockRejectedValueOnce(mockError);\n\n      await expect(\n        releasesController.createRelease(mockProjectId, mockDataset, mockReleaseId, mockTitle)\n      ).rejects.toThrow('Failed to create release: Test error');\n\n      expect(sanityApi.performActions).toHaveBeenCalled();\n    });\n  });\n\n  describe('addDocumentToRelease', () => {\n    it('should add a document to a release when content is provided', async () => {\n      const mockContent = { _id: mockDocumentId, title: 'Test Doc', _type: 'article' };\n      const mockResult = { transactionId: 'tx123' };\n      \n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.addDocumentToRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId,\n        mockDocumentId,\n        mockContent\n      );\n\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.document.version.create',\n            publishedId: mockDocumentId,\n            attributes: {\n              ...mockContent,\n              _id: `versions.${mockReleaseId}.${mockDocumentId}`\n            }\n          }\n        ]\n      );\n\n      expect(result).toEqual({\n        success: true,\n        message: `1 document(s) added to release ${mockReleaseId} successfully`,\n        releaseId: mockReleaseId,\n        documentIds: [mockDocumentId],\n        versionIds: [`versions.${mockReleaseId}.${mockDocumentId}`],\n        result: mockResult\n      });\n    });\n\n    it('should fetch document content when not provided', async () => {\n      const mockDoc = { _id: mockDocumentId, title: 'Test Doc', _type: 'article' };\n      const mockResult = { transactionId: 'tx123' };\n      \n      mockClient.getDocument.mockResolvedValueOnce(mockDoc);\n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.addDocumentToRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId,\n        mockDocumentId\n      );\n\n      expect(mockClient.getDocument).toHaveBeenCalledWith(`drafts.${mockDocumentId}`);\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.document.version.create',\n            publishedId: mockDocumentId,\n            attributes: {\n              ...mockDoc,\n              _id: `versions.${mockReleaseId}.${mockDocumentId}`\n            }\n          }\n        ]\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.documentIds).toContain(mockDocumentId);\n      expect(result.documentIds.length).toBe(1);\n    });\n  });\n\n  describe('listReleaseDocuments', () => {\n    it('should list all documents in a release', async () => {\n      const mockDocs = [\n        { _id: `versions.${mockReleaseId}.doc1`, _type: 'post', title: 'Post 1' },\n        { _id: `versions.${mockReleaseId}.doc2`, _type: 'post', title: 'Post 2' }\n      ];\n      \n      mockClient.fetch.mockResolvedValueOnce(mockDocs);\n\n      const result = await releasesController.listReleaseDocuments(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId\n      );\n\n      expect(mockClient.fetch).toHaveBeenCalledWith(\n        `*[sanity::partOfRelease($releaseId)]{ _id, _type, title }`,\n        { releaseId: mockReleaseId }\n      );\n      expect(result).toEqual({\n        releaseId: mockReleaseId,\n        documentCount: 2,\n        documents: [\n          {\n            versionId: 'versions.test-release-123.doc1',\n            documentId: 'doc1',\n            type: 'post',\n            title: 'Post 1'\n          },\n          {\n            versionId: 'versions.test-release-123.doc2',\n            documentId: 'doc2',\n            type: 'post',\n            title: 'Post 2'\n          }\n        ]\n      });\n    });\n    \n    it('should handle empty releases', async () => {\n      mockClient.fetch.mockResolvedValueOnce([]);\n      \n      const result = await releasesController.listReleaseDocuments(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId\n      );\n      \n      expect(mockClient.fetch).toHaveBeenCalledWith(\n        `*[sanity::partOfRelease($releaseId)]{ _id, _type, title }`,\n        { releaseId: mockReleaseId }\n      );\n      \n      expect(result).toEqual({\n        releaseId: mockReleaseId,\n        documentCount: 0,\n        documents: []\n      });\n    });\n  });\n\n  describe('publishRelease', () => {\n    it('should publish a release', async () => {\n      const mockDocs = [\n        { _id: `versions.${mockReleaseId}.doc1`, _type: 'post', title: 'Post 1' }\n      ];\n      const mockResult = { transactionId: 'tx123' };\n      \n      mockClient.fetch.mockResolvedValueOnce(mockDocs);\n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.publishRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId\n      );\n\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.release.publish',\n            releaseId: mockReleaseId\n          }\n        ]\n      );\n\n      expect(result).toEqual({\n        success: true,\n        message: `Release ${mockReleaseId} published successfully`,\n        releaseId: mockReleaseId,\n        documentCount: 1,\n        result: mockResult\n      });\n    });\n\n    it('should throw error if release has too many documents', async () => {\n      // Generate 51 mock documents to exceed the 50 document limit\n      const mockDocs = Array.from({ length: 51 }).map((_, i) => ({\n        _id: `versions.${mockReleaseId}.doc${i}`,\n        _type: 'post',\n        title: `Post ${i}`\n      }));\n      \n      mockClient.fetch.mockResolvedValueOnce(mockDocs);\n\n      await expect(\n        releasesController.publishRelease(mockProjectId, mockDataset, mockReleaseId)\n      ).rejects.toThrow(/Release contains 51 documents, which exceeds the 50 document limit/);\n\n      expect(sanityApi.performActions).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('listReleases', () => {\n    it('should list all releases', async () => {\n      const mockReleases = [\n        { _id: '_.releases.rel1', name: 'rel1', state: 'active' },\n        { _id: '_.releases.rel2', name: 'rel2', state: 'published' }\n      ];\n      \n      mockClient.fetch.mockResolvedValueOnce(mockReleases);\n\n      const result = await releasesController.listReleases(\n        mockProjectId,\n        mockDataset\n      );\n\n      expect(mockClient.fetch).toHaveBeenCalledWith('releases::all()');\n      expect(result).toEqual({\n        releases: mockReleases\n      });\n    });\n  });\n\n  describe('updateRelease', () => {\n    it('should update a release with provided fields', async () => {\n      const mockUpdate = {\n        title: 'Updated Title',\n        description: 'Updated description'\n      };\n      const mockResult = { transactionId: 'tx123' };\n      \n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.updateRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId,\n        mockUpdate\n      );\n\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.release.edit',\n            releaseId: mockReleaseId,\n            patch: {\n              id: mockReleaseId,\n              set: {\n                metadata: {\n                  title: 'Updated Title',\n                  description: 'Updated description'\n                }\n              }\n            }\n          }\n        ]\n      );\n\n      expect(result.success).toBe(true);\n    });\n  });\n\n  describe('removeDocumentFromRelease', () => {\n    it('should remove a single document from a release', async () => {\n      const mockResult = { transactionId: 'tx123' };\n      \n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.removeDocumentFromRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId,\n        mockDocumentId\n      );\n\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.document.delete',\n            documentId: `versions.${mockReleaseId}.${mockDocumentId}`\n          }\n        ]\n      );\n\n      expect(result).toEqual({\n        success: true,\n        message: `1 document(s) removed from release ${mockReleaseId} successfully`,\n        releaseId: mockReleaseId,\n        documentIds: [mockDocumentId],\n        result: mockResult\n      });\n    });\n\n    it('should remove multiple documents from a release when given an array of IDs', async () => {\n      const mockDocumentIds = ['doc1', 'doc2', 'doc3'];\n      const mockResult = { transactionId: 'tx123' };\n      \n      // Mock the performActions function to return a single result\n      (sanityApi.performActions as any).mockResolvedValueOnce(mockResult);\n\n      const result = await releasesController.removeDocumentFromRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId,\n        mockDocumentIds\n      );\n\n      // Verify that performActions was called once with all document actions\n      expect(sanityApi.performActions).toHaveBeenCalledTimes(1);\n      \n      // Check that all document IDs were included in a single call\n      expect(sanityApi.performActions).toHaveBeenCalledWith(\n        mockProjectId,\n        mockDataset,\n        [\n          {\n            actionType: 'sanity.action.document.delete',\n            documentId: `versions.${mockReleaseId}.${mockDocumentIds[0]}`\n          },\n          {\n            actionType: 'sanity.action.document.delete',\n            documentId: `versions.${mockReleaseId}.${mockDocumentIds[1]}`\n          },\n          {\n            actionType: 'sanity.action.document.delete',\n            documentId: `versions.${mockReleaseId}.${mockDocumentIds[2]}`\n          }\n        ]\n      );\n\n      // Verify the result structure\n      expect(result).toEqual({\n        success: true,\n        message: `${mockDocumentIds.length} document(s) removed from release ${mockReleaseId} successfully`,\n        releaseId: mockReleaseId,\n        documentIds: mockDocumentIds,\n        result: mockResult\n      });\n    });\n\n    it('should handle errors when removing a document from a release', async () => {\n      const mockError = new Error('Version deletion failed');\n      \n      (sanityApi.performActions as any).mockRejectedValueOnce(mockError);\n\n      await expect(\n        releasesController.removeDocumentFromRelease(\n          mockProjectId,\n          mockDataset,\n          mockReleaseId,\n          mockDocumentId\n        )\n      ).rejects.toThrow(`Failed to remove document(s) from release ${mockReleaseId}: Version deletion failed`);\n\n      expect(sanityApi.performActions).toHaveBeenCalled();\n    });\n  });\n\n  describe('getRelease', () => {\n    it('should get a release by ID', async () => {\n      const mockReleaseData = {\n        _id: `_.releases.${mockReleaseId}`,\n        title: 'Test Release',\n        status: 'active'\n      };\n      \n      mockClient.fetch.mockResolvedValueOnce([mockReleaseData]);\n\n      const result = await releasesController.getRelease(\n        mockProjectId,\n        mockDataset,\n        mockReleaseId\n      );\n\n      expect(mockClient.fetch).toHaveBeenCalledWith(\n        `*[_id == \"_.releases.${mockReleaseId}\"]`\n      );\n\n      expect(result).toEqual({\n        release: mockReleaseData\n      });\n    });\n\n    it('should throw an error when release is not found', async () => {\n      mockClient.fetch.mockResolvedValueOnce([]);\n\n      await expect(\n        releasesController.getRelease(\n          mockProjectId,\n          mockDataset,\n          mockReleaseId\n        )\n      ).rejects.toThrow('Failed to get release: Release with ID');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/controllers/schema.test.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 14 times.","line":71,"column":55,"nodeType":"Literal","endLine":71,"endColumn":69},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 14 times.","line":71,"column":71,"nodeType":"Literal","endLine":71,"endColumn":85}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\nimport * as fs from 'fs/promises';\nimport * as schemaController from '../../src/controllers/schema.js';\nimport config from '../../src/config/config.js';\n\nvi.mock('fs/promises');\nvi.mock('../../src/config/config.js', () => ({\n  default: {\n    getSchemaPath: vi.fn(),\n  }\n}));\n\ndescribe('Schema Controller', () => {\n  // Define mock schema for testing\n  const mockSchema = [\n    {\n      name: 'author',\n      type: 'document',\n      fields: [\n        { name: 'name', type: 'string' },\n        { name: 'bio', type: 'text' }\n      ]\n    },\n    {\n      name: 'post',\n      type: 'document',\n      fields: [\n        { name: 'title', type: 'string' },\n        { \n          name: 'author', \n          type: 'reference', \n          to: { type: 'author' } \n        },\n        {\n          name: 'categories',\n          type: 'array',\n          of: [{ type: 'reference', to: { type: 'category' } }]\n        },\n        {\n          name: 'content',\n          type: 'array',\n          of: [{ type: 'block' }]\n        }\n      ]\n    },\n    {\n      name: 'category',\n      type: 'type',\n      fields: [\n        { name: 'title', type: 'string' }\n      ]\n    },\n    {\n      name: 'block',\n      type: 'type',\n      fields: [\n        { name: 'text', type: 'string' }\n      ]\n    }\n  ];\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n    vi.spyOn(console, 'error').mockImplementation(() => {});\n    vi.mocked(config.getSchemaPath).mockReturnValue('/mock/path/to/schema.json');\n    vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify(mockSchema));\n  });\n\n  describe('getSchema', () => {\n    it('should return schema from file if it exists', async () => {\n      const result = await schemaController.getSchema('mock-project', 'mock-dataset');\n      \n      expect(result).toEqual(mockSchema);\n      expect(config.getSchemaPath).toHaveBeenCalledWith('mock-project', 'mock-dataset');\n      expect(fs.readFile).toHaveBeenCalledWith('/mock/path/to/schema.json', 'utf-8');\n    });\n\n    it('should throw an error if schema file does not exist', async () => {\n      const error = new Error('File not found') as NodeJS.ErrnoException;\n      error.code = 'ENOENT';\n      \n      vi.mocked(fs.readFile).mockRejectedValueOnce(error);\n      \n      await expect(schemaController.getSchema('mock-project', 'mock-dataset'))\n        .rejects\n        .toThrow('Schema file not found for project mock-project and dataset mock-dataset');\n    });\n\n    it('should throw on other file read errors', async () => {\n      const error = new Error('Some other error');\n      vi.mocked(fs.readFile).mockRejectedValueOnce(error);\n      \n      await expect(schemaController.getSchema('mock-project', 'mock-dataset'))\n        .rejects\n        .toThrow('Failed to get schema:');\n    });\n  });\n\n  describe('listSchemaTypes', () => {\n    it('should list only document types by default', async () => {\n      const result = await schemaController.listSchemaTypes('mock-project', 'mock-dataset');\n      \n      // Should only include document types\n      expect(result).toEqual([\n        { name: 'author', type: 'document' },\n        { name: 'post', type: 'document' }\n      ]);\n    });\n\n    it('should list all types when allTypes option is true', async () => {\n      const result = await schemaController.listSchemaTypes('mock-project', 'mock-dataset', { allTypes: true });\n      \n      // Should include all types\n      expect(result).toEqual([\n        { name: 'author', type: 'document' },\n        { name: 'post', type: 'document' },\n        { name: 'category', type: 'type' },\n        { name: 'block', type: 'type' }\n      ]);\n    });\n\n    it('should catch and rethrow errors', async () => {\n      const error = new Error('Schema error');\n      vi.mocked(fs.readFile).mockRejectedValueOnce(error);\n      \n      await expect(schemaController.listSchemaTypes('mock-project', 'mock-dataset'))\n        .rejects\n        .toThrow('Failed to list schema types:');\n        \n      expect(console.error).toHaveBeenCalled();\n    });\n  });\n\n  describe('getTypeSchema', () => {\n    it('should return the schema for a document type', async () => {\n      const result = await schemaController.getTypeSchema('mock-project', 'mock-dataset', 'author');\n      \n      expect(result.name).toBe('author');\n      expect(result.type).toBe('document');\n    });\n\n    it('should return the schema for a custom type', async () => {\n      const result = await schemaController.getTypeSchema('mock-project', 'mock-dataset', 'category');\n      \n      expect(result.name).toBe('category');\n      expect(result.type).toBe('type');\n    });\n\n    it('should throw an error if type is not found', async () => {\n      await expect(schemaController.getTypeSchema('mock-project', 'mock-dataset', 'nonexistent'))\n        .rejects\n        .toThrow(\"Type 'nonexistent' not found in schema\");\n    });\n  });\n\n  describe('getSchemaForType', () => {\n    it('should get document schema for a type', async () => {\n      const result = await schemaController.getSchemaForType('mock-project', 'mock-dataset', 'author');\n      \n      expect(result.name).toBe('author');\n      expect(result.type).toBe('document');\n    });\n\n    it('should get non-document schema for a type', async () => {\n      const result = await schemaController.getSchemaForType('mock-project', 'mock-dataset', 'category');\n      \n      expect(result.name).toBe('category');\n      expect(result.type).toBe('type');\n    });\n\n    it('should include referenced types when includeReferences is true', async () => {\n      const result = await schemaController.getSchemaForType('mock-project', 'mock-dataset', 'post', { includeReferences: true });\n      \n      expect(result.name).toBe('post');\n      expect(result.references).toBeDefined();\n      expect(result.references.length).toBeGreaterThan(0);\n      \n      // Check that referenced types are included\n      const referenceNames = result.references.map(ref => ref.name);\n      expect(referenceNames).toContain('author');\n      expect(referenceNames).toContain('category');\n    });\n\n    it('should throw error when type is not found', async () => {\n      await expect(schemaController.getSchemaForType('mock-project', 'mock-dataset', 'nonexistent'))\n        .rejects\n        .toThrow('Type nonexistent not found in schema');\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/integration/array-parameter-deserialization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/integration/release-document-workflow.test.ts","messages":[{"ruleId":"complexity","severity":2,"message":"Async arrow function has a complexity of 13. Maximum allowed is 10.","line":51,"column":12,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":137,"endColumn":4},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 24 to the 10 allowed.","line":51,"column":21,"nodeType":null,"messageId":"refactorFunction","endLine":51,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration test for the full release and document workflow\n * Tests creation of releases, documents, adding versions, and cleanup\n */\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\nimport dotenv from 'dotenv';\nimport { v4 as uuidv4 } from 'uuid';\nimport * as actionsController from '../../src/controllers/actions.js';\nimport * as releasesController from '../../src/controllers/releases.js';\nimport { createSanityClient } from '../../src/utils/sanityClient.js';\n\n// Load environment variables\ndotenv.config();\n\ndescribe('Release and Document Workflow Integration', () => {\n  // Configuration from environment\n  const projectId = process.env.SANITY_PROJECT_ID || '';\n  const dataset = process.env.SANITY_DATASET || 'production';\n  \n  // Test identifiers with unique IDs to avoid conflicts\n  const testPrefix = 'integration-test';\n  const releaseId = `${testPrefix}-release-${uuidv4().substring(0, 8)}`;\n  const documentId = `${testPrefix}-doc-${uuidv4().substring(0, 8)}`;\n  const draftDocumentId = `drafts.${documentId}`;\n  const documentId2 = `${testPrefix}-doc2-${uuidv4().substring(0, 8)}`;\n  const documentId3 = `${testPrefix}-doc3-${uuidv4().substring(0, 8)}`;\n  const draftDocumentId2 = `drafts.${documentId2}`;\n  const draftDocumentId3 = `drafts.${documentId3}`;\n  \n  // Set a longer timeout for integration tests\n  const INTEGRATION_TIMEOUT = 15000;\n  \n  // Track created resources for cleanup\n  const resourcesToCleanup = {\n    releaseId: '',\n    documentId: '',\n    documentVersionId: '',\n    documentId2: '',\n    documentId3: '',\n    documentVersionIds: [] as string[]\n  };\n\n  // Skip tests if environment is not properly configured\n  beforeAll(() => {\n    if (!projectId) {\n      throw new Error('SANITY_PROJECT_ID environment variable is required for this test');\n    }\n  }, INTEGRATION_TIMEOUT);\n\n  // Clean up all resources after tests\n  afterAll(async () => {\n    // Only attempt cleanup if resources were created\n    try {\n      // Clean up document version if it was created\n      if (resourcesToCleanup.documentVersionId) {\n        await actionsController.discardDocumentVersion(\n          projectId, \n          dataset,\n          resourcesToCleanup.documentVersionId\n        );\n        console.log(`Cleaned up document version: ${resourcesToCleanup.documentVersionId}`);\n      }\n      \n      // Clean up document if it was created\n      if (resourcesToCleanup.documentId) {\n        // Use direct client delete since our IDs might not be correct\n        const client = createSanityClient(projectId, dataset);\n        try {\n          // Try to delete both the draft and published versions\n          await client.delete(documentId);\n          console.log(`Cleaned up published document: ${documentId}`);\n        } catch (err) {\n          console.log(`No published document to clean up: ${documentId}`);\n        }\n        \n        try {\n          await client.delete(draftDocumentId);\n          console.log(`Cleaned up draft document: ${draftDocumentId}`);\n        } catch (err) {\n          console.log(`No draft document to clean up: ${draftDocumentId}`);\n        }\n\n        // Clean up additional documents\n        if (resourcesToCleanup.documentId2) {\n          try {\n            await client.delete(documentId2);\n            console.log(`Cleaned up published document: ${documentId2}`);\n          } catch (err) {\n            console.log(`No published document to clean up: ${documentId2}`);\n          }\n          \n          try {\n            await client.delete(draftDocumentId2);\n            console.log(`Cleaned up draft document: ${draftDocumentId2}`);\n          } catch (err) {\n            console.log(`No draft document to clean up: ${draftDocumentId2}`);\n          }\n        }\n\n        if (resourcesToCleanup.documentId3) {\n          try {\n            await client.delete(documentId3);\n            console.log(`Cleaned up published document: ${documentId3}`);\n          } catch (err) {\n            console.log(`No published document to clean up: ${documentId3}`);\n          }\n          \n          try {\n            await client.delete(draftDocumentId3);\n            console.log(`Cleaned up draft document: ${draftDocumentId3}`);\n          } catch (err) {\n            console.log(`No draft document to clean up: ${draftDocumentId3}`);\n          }\n        }\n      }\n      \n      // Clean up release if it was created\n      if (resourcesToCleanup.releaseId) {\n        // First archive the release (required before deletion)\n        await releasesController.archiveRelease(\n          projectId,\n          dataset,\n          resourcesToCleanup.releaseId\n        );\n        \n        // Then delete the archived release\n        await releasesController.deleteRelease(\n          projectId,\n          dataset,\n          resourcesToCleanup.releaseId\n        );\n        console.log(`Cleaned up release: ${resourcesToCleanup.releaseId}`);\n      }\n    } catch (error) {\n      console.error('Error during cleanup:', error);\n    }\n  }, INTEGRATION_TIMEOUT);\n\n  it('should create a release', async () => {\n    // Create a new release\n    const result = await releasesController.createRelease(\n      projectId,\n      dataset,\n      releaseId,\n      `Integration Test Release ${new Date().toISOString()}`,\n      {\n        description: 'Created by integration tests - will be auto-cleaned up',\n        releaseType: 'asap'\n      }\n    );\n    \n    // Store ID for cleanup\n    resourcesToCleanup.releaseId = releaseId;\n    \n    // Verify the release was created successfully\n    expect(result.success).toBe(true);\n    expect(result.releaseId).toBe(releaseId);\n  }, INTEGRATION_TIMEOUT);\n\n  it('should create a document', async () => {\n    // Create a test document with direct client to ensure success\n    const client = createSanityClient(projectId, dataset);\n    \n    const testDocument = {\n      _id: documentId,\n      _type: 'test',\n      title: 'Integration Test Document',\n      description: 'Created by integration tests - will be auto-cleaned up',\n      createdAt: new Date().toISOString()\n    };\n    \n    // Create the document directly using the client\n    const createdDoc = await client.createOrReplace(testDocument);\n    \n    // Store the document ID for cleanup\n    resourcesToCleanup.documentId = documentId;\n    \n    // Verify the document was created\n    expect(createdDoc._id).toBe(documentId);\n  }, INTEGRATION_TIMEOUT);\n\n  it('should add document to a release', async () => {\n    // Use the releases controller to add the document to the release\n    const result = await releasesController.addDocumentToRelease(\n      projectId,\n      dataset,\n      releaseId,\n      documentId\n    );\n    \n    // Verify the document was added to the release\n    expect(result.success).toBe(true);\n    expect(result.releaseId).toBe(releaseId);\n    expect(result.documentIds).toContain(documentId);\n    \n    // Store the version ID for cleanup\n    if (result.versionIds && result.versionIds.length > 0) {\n      resourcesToCleanup.documentVersionId = result.versionIds[0];\n    }\n    \n    // Wait briefly to ensure document is processed\n    await new Promise(resolve => setTimeout(resolve, 1000));\n  }, INTEGRATION_TIMEOUT);\n\n  it('should list documents in a release', async () => {\n    // Get list of documents in the release\n    const result = await releasesController.listReleaseDocuments(\n      projectId,\n      dataset,\n      releaseId\n    );\n    \n    // Verify our document is in the release\n    expect(result.releaseId).toBe(releaseId);\n    expect(result.documentCount).toBeGreaterThan(0);\n    \n    // Find our document in the list\n    const ourDocument = result.documents.find(doc => doc.documentId === documentId);\n    expect(ourDocument).toBeDefined();\n  }, INTEGRATION_TIMEOUT);\n\n  it('should update a document', async () => {\n    // Direct client update instead of patch to ensure success\n    const client = createSanityClient(projectId, dataset);\n    \n    // Fetch the current document\n    const currentDocument = await client.getDocument(documentId);\n    expect(currentDocument).toBeTruthy();\n    \n    // Update fields\n    const updatedDocument = {\n      ...currentDocument,\n      updatedAt: new Date().toISOString(),\n      status: 'updated',\n      _id: documentId // Ensure _id is explicitly set\n    };\n    \n    // Replace the document\n    const result = await client.createOrReplace(updatedDocument);\n    \n    // Verify the document was updated\n    expect(result._id).toBe(documentId);\n    expect(result.status).toBe('updated');\n  }, INTEGRATION_TIMEOUT);\n\n  it('should create a document version with updated content', async () => {\n    // Create a new version document with custom content\n    const customContent = {\n      _id: documentId,\n      _type: 'test',\n      title: 'Updated Document Title',\n      description: 'This content is provided explicitly rather than fetched',\n      updatedAt: new Date().toISOString(),\n      status: 'manually-specified'\n    };\n    \n    // Create a new version of the document in the release\n    const result = await actionsController.createDocumentVersion(\n      projectId,\n      dataset,\n      releaseId,\n      documentId,\n      customContent\n    );\n    \n    // Update version ID for cleanup if needed\n    if (result.versionId) {\n      resourcesToCleanup.documentVersionId = result.versionId;\n    }\n    \n    // Verify the version was created\n    expect(result.success).toBe(true);\n    expect(result.versionId).toBeTruthy();\n  }, INTEGRATION_TIMEOUT);\n\n  it('should create additional test documents', async () => {\n    // Create two additional test documents for the array test\n    const client = createSanityClient(projectId, dataset);\n    \n    const testDocument2 = {\n      _id: documentId2,\n      _type: 'test',\n      title: 'Integration Test Document 2',\n      description: 'Second test document for array testing',\n      createdAt: new Date().toISOString()\n    };\n    \n    const testDocument3 = {\n      _id: documentId3,\n      _type: 'test',\n      title: 'Integration Test Document 3',\n      description: 'Third test document for array testing',\n      createdAt: new Date().toISOString()\n    };\n    \n    // Create the documents\n    const createdDoc2 = await client.createOrReplace(testDocument2);\n    const createdDoc3 = await client.createOrReplace(testDocument3);\n    \n    // Store the document IDs for cleanup\n    resourcesToCleanup.documentId2 = documentId2;\n    resourcesToCleanup.documentId3 = documentId3;\n    \n    // Verify the documents were created\n    expect(createdDoc2._id).toBe(documentId2);\n    expect(createdDoc3._id).toBe(documentId3);\n  }, INTEGRATION_TIMEOUT);\n\n  it('should add multiple documents to a release as an array', async () => {\n    // Add both documents to the release using the array parameter\n    const result = await releasesController.addDocumentToRelease(\n      projectId,\n      dataset,\n      releaseId,\n      [documentId2, documentId3]\n    );\n    \n    // Verify the documents were added to the release\n    expect(result.success).toBe(true);\n    expect(result.releaseId).toBe(releaseId);\n    expect(result.documentIds).toContain(documentId2);\n    expect(result.documentIds).toContain(documentId3);\n    \n    // Store version IDs for cleanup\n    if (result.versionIds && result.versionIds.length > 0) {\n      resourcesToCleanup.documentVersionIds = result.versionIds;\n    }\n    \n    // Wait briefly to ensure documents are processed\n    await new Promise(resolve => setTimeout(resolve, 1000));\n  }, INTEGRATION_TIMEOUT);\n\n  it('should list all documents in the release including the array-added ones', async () => {\n    // Get list of documents in the release\n    const result = await releasesController.listReleaseDocuments(\n      projectId,\n      dataset,\n      releaseId\n    );\n    \n    // Verify all three documents are in the release\n    expect(result.releaseId).toBe(releaseId);\n    expect(result.documentCount).toBeGreaterThanOrEqual(3);\n    \n    // Find our documents in the list\n    const document1 = result.documents.find(doc => doc.documentId === documentId);\n    const document2 = result.documents.find(doc => doc.documentId === documentId2);\n    const document3 = result.documents.find(doc => doc.documentId === documentId3);\n    \n    expect(document1).toBeDefined();\n    expect(document2).toBeDefined();\n    expect(document3).toBeDefined();\n  }, INTEGRATION_TIMEOUT);\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/integration/schema-single-types.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/integration/semantic-search.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/tools/index.test.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":106,"column":8,"nodeType":"Literal","endLine":106,"endColumn":22},{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 4 times.","line":110,"column":8,"nodeType":"Literal","endLine":110,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Tools Registry Tests\n * \n * Tests the tools registry functionality and individual tool definitions\n */\nimport { describe, it, expect, beforeAll } from 'vitest';\nimport * as toolsRegistry from '../../src/tools/index.js';\nimport { SchemaToolProvider } from '../../src/tools/schemaTools.js';\nimport { MutateToolProvider } from '../../src/tools/mutateTools.js';\nimport { EmbeddingsToolProvider } from '../../src/tools/embeddingsTools.js';\nimport { GroqToolProvider } from '../../src/tools/groqTools.js';\n\ndescribe('Tools', () => {\n  let allTools;\n  let schemaTools;\n  let mutateTools;\n  let embeddingsTools;\n  let groqTools;\n  let getTypeSchemaTool;\n  let mutateDocumentTool;\n  let executeGroqTool;\n  let semanticSearchTool;\n\n  beforeAll(() => {\n    // Get all tools\n    allTools = toolsRegistry.getToolDefinitions();\n    \n    // Get individual provider's tools\n    schemaTools = new SchemaToolProvider().getToolDefinitions();\n    mutateTools = new MutateToolProvider().getToolDefinitions();\n    embeddingsTools = new EmbeddingsToolProvider().getToolDefinitions();\n    groqTools = new GroqToolProvider().getToolDefinitions();\n    \n    // Find specific tools\n    getTypeSchemaTool = schemaTools.find(tool => tool.name === 'getTypeSchema');\n    mutateDocumentTool = mutateTools.find(tool => tool.name === 'mutateDocument');\n    executeGroqTool = groqTools.find(tool => tool.name === 'executeGroq');\n    semanticSearchTool = embeddingsTools.find(tool => tool.name === 'semanticSearch');\n  });\n\n  describe('getToolDefinitions', () => {\n    it('should return an array of tool definitions', () => {\n      expect(Array.isArray(allTools)).toBe(true);\n      expect(allTools.length).toBeGreaterThan(0);\n    });\n\n    it('should include schema tools', () => {\n      // Check if schema tools are included in the main tool registry\n      const hasSchemaTools = allTools.some(tool => \n        tool.name === 'getTypeSchema'\n      );\n      expect(hasSchemaTools).toBe(true);\n      \n      // Additionally validate that the schema tool provider returns this tool\n      expect(getTypeSchemaTool).toBeDefined();\n    });\n\n    it('should include mutate tools', () => {\n      // Check if mutate tools are included in the main tool registry\n      const hasMutateTools = allTools.some(tool => \n        tool.name === 'mutateDocument'\n      );\n      expect(hasMutateTools).toBe(true);\n      \n      // Additionally validate that the mutate tool provider returns this tool\n      expect(mutateDocumentTool).toBeDefined();\n    });\n\n    it('should include GROQ tools', () => {\n      // Check if GROQ tools are included in the main tool registry\n      const hasGroqTools = allTools.some(tool => \n        tool.name === 'executeGroq'\n      );\n      expect(hasGroqTools).toBe(true);\n      \n      // Additionally validate that the GROQ tool provider returns this tool\n      expect(executeGroqTool).toBeDefined();\n    });\n\n    it('should include embeddings tools', () => {\n      // Check if embeddings tools are included in the main tool registry\n      const hasEmbeddingsTools = allTools.some(tool => \n        tool.name === 'semanticSearch'\n      );\n      expect(hasEmbeddingsTools).toBe(true);\n      \n      // Additionally validate that the embeddings tool provider returns this tool\n      expect(semanticSearchTool).toBeDefined();\n    });\n  });\n\n  describe('getToolDefinition', () => {\n    it('should return the correct tool definition by name', () => {\n      const tool = toolsRegistry.getToolDefinition('getSchema');\n      expect(tool).toBeDefined();\n      expect(tool.name).toBe('getSchema');\n    });\n\n    it('should return null for unknown tool name', () => {\n      const tool = toolsRegistry.getToolDefinition('nonExistentTool');\n      expect(tool).toBeNull();\n    });\n  });\n\n  describe('getTypeSchema', () => {\n    it('should exist', () => {\n      expect(getTypeSchemaTool).toBeDefined();\n    });\n\n    it('should have correct parameters', () => {\n      const paramSchema = getTypeSchemaTool.parameters.shape;\n      expect(paramSchema.typeName).toBeDefined();\n      expect(paramSchema.projectId).toBeDefined();\n      expect(paramSchema.dataset).toBeDefined();\n    });\n  });\n\n  describe('mutateDocument', () => {\n    it('should exist', () => {\n      expect(mutateDocumentTool).toBeDefined();\n    });\n\n    it('should have correct parameters', () => {\n      const paramSchema = mutateDocumentTool.parameters.shape;\n      expect(paramSchema.mutations).toBeDefined();\n      expect(paramSchema.projectId).toBeDefined();\n      expect(paramSchema.dataset).toBeDefined();\n      expect(paramSchema.returnDocuments).toBeDefined();\n    });\n  });\n\n  describe('executeGroq', () => {\n    it('should exist', () => {\n      expect(executeGroqTool).toBeDefined();\n    });\n\n    it('should have correct parameters', () => {\n      const paramSchema = executeGroqTool.parameters.shape;\n      expect(paramSchema.query).toBeDefined();\n      expect(paramSchema.projectId).toBeDefined();\n      expect(paramSchema.dataset).toBeDefined();\n      expect(paramSchema.params).toBeDefined();\n    });\n  });\n\n  describe('semanticSearch', () => {\n    it('should exist', () => {\n      expect(semanticSearchTool).toBeDefined();\n    });\n\n    it('should have correct parameters', () => {\n      const paramSchema = semanticSearchTool.parameters.shape;\n      expect(paramSchema.query).toBeDefined();\n      expect(paramSchema.indexName).toBeDefined();\n      expect(paramSchema.projectId).toBeDefined();\n      expect(paramSchema.dataset).toBeDefined();\n      expect(paramSchema.maxResults).toBeDefined();\n      expect(paramSchema.types).toBeDefined();\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/test/utils/sanityClient.test.ts","messages":[{"ruleId":"sonarjs/no-duplicate-string","severity":1,"message":"Define a constant instead of duplicating this literal 9 times.","line":7,"column":51,"nodeType":"Literal","endLine":7,"endColumn":63}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect, describe, it } from 'vitest';\nimport { isSufficientApiVersion } from '../../src/utils/sanityClient.ts';\n\ndescribe('Sanity Client Utilities', () => {\n  describe('isSufficientApiVersion', () => {\n    it('should return true when current version is newer than required', () => {\n      expect(isSufficientApiVersion('2025-03-01', '2025-02-19')).toBe(true);\n      expect(isSufficientApiVersion('2026-01-01', '2025-02-19')).toBe(true);\n      expect(isSufficientApiVersion('2025-02-20', '2025-02-19')).toBe(true);\n    });\n\n    it('should return true when current version equals required version', () => {\n      expect(isSufficientApiVersion('2025-02-19', '2025-02-19')).toBe(true);\n    });\n\n    it('should return false when current version is older than required', () => {\n      expect(isSufficientApiVersion('2024-10-01', '2025-02-19')).toBe(false);\n      expect(isSufficientApiVersion('2025-01-01', '2025-02-19')).toBe(false);\n      expect(isSufficientApiVersion('2025-02-18', '2025-02-19')).toBe(false);\n    });\n\n    it('should handle v-prefixed versions correctly', () => {\n      expect(isSufficientApiVersion('v2025-03-01', '2025-02-19')).toBe(true);\n      expect(isSufficientApiVersion('2025-03-01', 'v2025-02-19')).toBe(true);\n    });\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/usage-example.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/even/projects/sanity/ai/mcp/sanity-mcp-server/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
